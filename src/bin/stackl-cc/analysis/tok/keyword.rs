use crate::analysis::prt::*;

#[derive(Debug, Clone)]
#[non_exhaustive]
pub enum Keyword {
	Asm,
	Auto,
	Break,
	Case,
	Char,
	Const,
	Continue,
	Default,
	Do,
	Double,
	Else,
	Enum,
	Extern,
	Float,
	For,
	Goto,
	If,
	Inline,
	Int,
	Long,
	Register,
	Restrict,
	Return,
	Short,
	Signed,
	Sizeof,
	Static,
	Struct,
	Switch,
	Typedef,
	Union,
	Unsigned,
	Void,
	Volatile,
	While,
	Bool,
}

impl TryFrom<&str> for Keyword {
	type Error = lex::TryFromIdentifierError;
	fn try_from(value: &str) -> Result<Self, Self::Error> {
		use Keyword as Term;
		let terminal = match value {
			"asm" => Term::Asm,
			"auto" => Term::Auto,
			"break" => Term::Break,
			"case" => Term::Case,
			"char" => Term::Char,
			"const" => Term::Const,
			"continue" => Term::Continue,
			"default" => Term::Default,
			"do" => Term::Do,
			"double" => Term::Double,
			"else" => Term::Else,
			"enum" => Term::Enum,
			"extern" => Term::Extern,
			"float" => Term::Float,
			"for" => Term::For,
			"goto" => Term::Goto,
			"if" => Term::If,
			"inline" => Term::Inline,
			"int" => Term::Int,
			"long" => Term::Long,
			"register" => Term::Register,
			"restrict" => Term::Restrict,
			"return" => Term::Return,
			"short" => Term::Short,
			"signed" => Term::Signed,
			"sizeof" => Term::Sizeof,
			"static" => Term::Static,
			"struct" => Term::Struct,
			"switch" => Term::Switch,
			"typedef" => Term::Typedef,
			"union" => Term::Union,
			"unsigned" => Term::Unsigned,
			"void" => Term::Void,
			"volatile" => Term::Volatile,
			"while" => Term::While,
			"_Bool" => Term::Bool,
			_ => return Err(lex::TryFromIdentifierError),
		};
		Ok(terminal)
	}
}
