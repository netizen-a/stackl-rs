use std::cell::RefCell;
use std::rc::Rc;
use std::io::{Read, BufReader};
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;

use crate::diagnostics::{self as diag,lex};
use lalrpop_util as lalr;
use crate::analysis::lex::PPTokenStack;
use crate::analysis::lex::lexer::Lexer;
use crate::analysis::tok::*;
use crate::diagnostics::ToSpan;

grammar<'a>(
	diagnostics: &mut diag::DiagnosticEngine,
	stack_ref: &'a Rc<RefCell<PPTokenStack>>,
);

pub Tokens: Vec<TokenTriple> = {
	GroupPart,
	<mut group: Tokens> <mut part: GroupPart> => {
		group.append(&mut part);
		group
	},
}

GroupPart: Vec<TokenTriple> = {
	// IfSection,
	ControlLine => vec![],
	TextLine,
	// "#" <non_dir:NonDirective> => non_dir,
	! => { diagnostics.push_preproc_error(<>.error); vec![] },
};

ControlLine: () = {
	// TODO: make this fallible
	"#" DIRECTIVE_INCLUDE <header:HEADER_NAME> "\n" => {
		let span = header.to_span();
		let origin_path = diagnostics.get_file_path(span.file_id).unwrap();
		let header_name = PathBuf::from(header.kind.to_name());
		let full_path = origin_path.parent().unwrap().join(header_name);
		let mut stack = stack_ref.borrow_mut();
		let file = fs::File::open(&full_path).unwrap();

		let mut reader = BufReader::new(file);
		let mut buf = String::new();
		reader.read_to_string(&mut buf).unwrap();

		let file_id = if let Some(file_id) = diagnostics.get_file_id(&full_path) {
			file_id
		} else {
			let file_id = diagnostics.id();
			diagnostics.insert_file_info(file_id, full_path);
			file_id
		};
		stack.push_lexer(Lexer::new(buf, file_id));
	},
	"#" DIRECTIVE_DEFINE <lo:@L> <ident:Identifier> <hi:@R> <list:ReplacementList> "\n" => {
		let name = ident.1.kind.clone().unwrap_name();
		let mut stack = stack_ref.borrow_mut();
		if let Some(error) = stack.define_obj_macro(name, list, ident.1.to_span()) {
			diagnostics.push(error);
		}
	},
	"#" DIRECTIVE_UNDEF <lo:@L> <ident:Identifier> <hi:@R> "\n" => {
		let name = ident.1.kind.clone().unwrap_name();
		let mut stack = stack_ref.borrow_mut();
		if let Some(error) = stack.undef_macro(name, ident.1.to_span()) {
			diagnostics.push(error);
		}
	},
	"#" DIRECTIVE_LINE <tokens:RawPPToken+> "\n" => {
		let mut stack = stack_ref.borrow_mut();
		if let Some(error) = stack.line_directive(tokens) {
			diagnostics.push(error);
		}
	},
	"#" <lo:@L> <directive:DIRECTIVE_ERROR> <hi:@R> <pp_token_list:RawPPToken*> "\n" => {
		let mut stack = stack_ref.borrow();
		let mut error_str = String::new();
		for (index, (_, pp_token, _)) in pp_token_list.iter().enumerate() {
			if index == 0 {
				// omit leading space
				error_str.push_str(&pp_token.kind.to_name());
			} else {
				error_str.push_str(&format!("{pp_token}"));
			}
		}
		let kind = diag::DiagKind::ErrorDirective(error_str);
		let diag = diag::Diagnostic::error(kind, directive.to_span());
		diagnostics.push(diag);
	},
	"#" DIRECTIVE_PRAGMA RawPPToken* "\n" => {},
	"#" "\n" => {},
};

TextLine: Vec<TokenTriple> = {
	"\n" => vec![],
	<nh:NonHash> <mut tokens: PreprocessingToken*> "\n" => {
		let mut result = vec![nh];
		result.append(&mut tokens);
		result
	},
};

ReplacementList: Vec<PPTokenTriple> = RawPPToken*;

RawPPToken: PPTokenTriple = {
	<lo:@L> <tk:IDENT> <hi:@R> => (lo,tk,hi),
	<lo:@L> <tk:PP_NUMBER> <hi:@R> => (lo,tk,hi),
	<lo:@L> <tk:CHAR_CONST> <hi:@R> => (lo,tk,hi),
	<lo:@L> <tk:STR_LIT> <hi:@R> => (lo,tk,hi),
	<lo:@L> <tk:PUNCT> <hi:@R> => (lo,tk,hi),
};

PreprocessingToken: TokenTriple = {
	Identifier,
	PPNumber,
	CharConst,
	StrLit,
	<lo:@L> <tk:PUNCT> <hi:@R> =>? {
		let mut stack = stack_ref.borrow();
		let span = tk.to_span();
		match tk.kind.try_into() {
			Ok(kind) => Ok((
				lo,
				Token { kind, span },
				hi
			)),
			Err(kind) => Err(lalr::ParseError::User {
				error: diag::Diagnostic::error(
					kind,
					span
				)
			}),
		}
	}
};

NonHash: TokenTriple = {
	Identifier,
	StrLit,
	PPNumber,
	CharConst,
	<lo:@L> <tk:NonHashPunct> <hi:@R> =>? {
		let mut stack = stack_ref.borrow();
		let span = tk.to_span();
		match tk.kind.try_into() {
			Ok(kind) => Ok((
				lo,
				Token{kind, span},
				hi
			)),
			Err(kind) => Err(lalr::ParseError::User {
				error: diag::Diagnostic::error(
					kind,
					span
				)
			}),
		}
	},
};

CharConst: TokenTriple = <lo:@L> <tk:CHAR_CONST> <hi:@R> =>? {
	let mut stack = stack_ref.borrow();
	let span = tk.to_span();
	match tk.kind.try_into() {
		Ok(kind) => Ok((
			lo,
			Token{kind, span},
			hi
		)),
		Err(kind) => Err(lalr::ParseError::User {
			error: diag::Diagnostic::error(
				kind,
				span
			)
		}),
	}
};

PPNumber: TokenTriple = <lo:@L> <tk:PP_NUMBER> <hi:@R> =>? {
	let mut stack = stack_ref.borrow();
	let span = tk.to_span();
	match tk.kind.try_into() {
		Ok(kind) => Ok((
			lo,
			Token{kind, span},
			hi
		)),
		Err(kind) => {
			eprintln!("pp-number error");
			Err(lalr::ParseError::User {
				error: diag::Diagnostic::error(
					kind,
					span
				)
			})
		},
	}
};

Identifier: TokenTriple = <lo:@L> <tk:IDENT> <hi:@R> =>? {
	let mut stack = stack_ref.borrow();
	let span = tk.to_span();
	match tk.kind.try_into() {
		Ok(kind) => Ok((
			lo,
			Token{kind, span},
			hi
		)),
		Err(kind) => {
			eprintln!("identifier error!");
			Err(lalr::ParseError::User {
				error: diag::Diagnostic::error(
					kind,
					span
				)
			})
		},
	}
};

StrLit: TokenTriple = <lo:@L> <tk:STR_LIT> <hi:@R> => {
	let mut stack = stack_ref.borrow();
	let span = tk.to_span();
	(
		lo,
		Token {
			kind: TokenKind::StrLit(tk.kind.unwrap_str_lit()),
			span,
		},
		hi
	)
};

PUNCT: PPToken = {
	"#",
	NonHashPunct,
};

NonHashPunct: PPToken = {
	"##",  "(", " (", ")",  "{",
	"}",   "*", "=",  ";",  ":",
	",",   "[", "]",  "?",  "~",
	"...", "+", "-",  "<<", ">>",
	"!",
};


extern {
	type Location = usize;
	type Error = diag::Diagnostic;

	enum PPToken {
		HEADER_NAME => PPToken{kind: PPTokenKind::HeaderName(_), ..},
		IDENT => PPToken{kind: PPTokenKind::Ident(_), ..},
		PP_NUMBER => PPToken{kind: PPTokenKind::PPNumber(_), ..},
		CHAR_CONST => PPToken{kind: PPTokenKind::CharConst(_), ..},
		STR_LIT => PPToken{kind: PPTokenKind::StrLit(_), ..},
		DIRECTIVE_INCLUDE => PPToken{kind: PPTokenKind::Directive(Directive::Include), ..},
		DIRECTIVE_IF => PPToken{kind: PPTokenKind::Directive(Directive::If), ..},
		DIRECTIVE_IFDEF => PPToken{kind: PPTokenKind::Directive(Directive::Ifdef), ..},
		DIRECTIVE_IfNDEF => PPToken{kind: PPTokenKind::Directive(Directive::Ifndef), ..},
		DIRECTIVE_ELIF => PPToken{kind: PPTokenKind::Directive(Directive::Elif), ..},
		DIRECTIVE_ELSE => PPToken{kind: PPTokenKind::Directive(Directive::Else), ..},
		DIRECTIVE_ENDIF => PPToken{kind: PPTokenKind::Directive(Directive::Endif), ..},
		DIRECTIVE_DEFINE => PPToken{kind: PPTokenKind::Directive(Directive::Define), ..},
		DIRECTIVE_UNDEF => PPToken{kind: PPTokenKind::Directive(Directive::Undef), ..},
		DIRECTIVE_LINE => PPToken{kind: PPTokenKind::Directive(Directive::Line), ..},
		DIRECTIVE_ERROR => PPToken{kind: PPTokenKind::Directive(Directive::Error), ..},
		DIRECTIVE_PRAGMA => PPToken{kind: PPTokenKind::Directive(Directive::Pragma), ..},
		"\n" => PPToken{kind: PPTokenKind::NewLine(_), ..},
		"#" => PPToken{kind: PPTokenKind::Punct(Punct::Hash), ..},
		"##" => PPToken{kind: PPTokenKind::Punct(Punct::HashHash), ..},
		"(" => PPToken{kind: PPTokenKind::Punct(Punct::LParen), leading_space: false, ..},
		" (" => PPToken{kind: PPTokenKind::Punct(Punct::LParen), leading_space: true, ..},
		")" => PPToken{kind: PPTokenKind::Punct(Punct::RParen), ..},
		"{" => PPToken{kind: PPTokenKind::Punct(Punct::LCurly), ..},
		"}" => PPToken{kind: PPTokenKind::Punct(Punct::RCurly), ..},
		"*" => PPToken{kind: PPTokenKind::Punct(Punct::Star), ..},
		"=" => PPToken{kind: PPTokenKind::Punct(Punct::Equal), ..},
		";" => PPToken{kind: PPTokenKind::Punct(Punct::SemiColon), ..},
		":" => PPToken{kind: PPTokenKind::Punct(Punct::Colon), ..},
		"," => PPToken{kind: PPTokenKind::Punct(Punct::Comma), ..},
		"[" => PPToken{kind: PPTokenKind::Punct(Punct::LSquare), ..},
		"]" => PPToken{kind: PPTokenKind::Punct(Punct::RSquare), ..},
		"?" => PPToken{kind: PPTokenKind::Punct(Punct::QMark), ..},
		"~" => PPToken{kind: PPTokenKind::Punct(Punct::Tilde), ..},
		"..." => PPToken{kind: PPTokenKind::Punct(Punct::Ellipsis), ..},
		"+" => PPToken{kind: PPTokenKind::Punct(Punct::Plus), ..},
		"-" => PPToken{kind: PPTokenKind::Punct(Punct::Minus), ..},
		"<<" => PPToken{kind: PPTokenKind::Punct(Punct::LessLess), ..},
		">>" => PPToken{kind: PPTokenKind::Punct(Punct::GreatGreat), ..},
		"!" => PPToken{kind: PPTokenKind::Punct(Punct::Bang), ..},
	}
}
