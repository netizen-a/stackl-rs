use std::cell::RefCell;
use std::rc::Rc;
use std::io::{Read, BufReader};
use std::fs;
use std::path::PathBuf;

use crate::diagnostics::{self as diag,lex};
use lalrpop_util as lalr;
use crate::analysis::lex::PPTokenStack;
use crate::analysis::lex::lexer::Lexer;
use crate::analysis::tok::*;
use crate::directive;

grammar<'a>(
	diagnostics: &mut diag::DiagnosticEngine,
	stack_ref: &'a Rc<RefCell<PPTokenStack>>
);

pub Tokens: Vec<TokenTriple> = {
	GroupPart,
	<mut group: Tokens> <mut part: GroupPart> => {
		group.append(&mut part);
		group
	},
}

GroupPart: Vec<TokenTriple> = {
	// IfSection,
	ControlLine,
	TextLine,
	// "#" <non_dir:NonDirective> => non_dir,
};

ControlLine: Vec<TokenTriple> = {
	// TODO: make this fallible
	"#" DirectiveInclude <header:HEADER_NAME> "\n" => {
		let origin_path = diagnostics.get_file_path(header.file_id).unwrap();
		let header_name = PathBuf::from(header.kind.to_name());
		let full_path = origin_path.parent().unwrap().join(header_name);
		let mut stack = stack_ref.borrow_mut();
		let file = fs::File::open(&full_path).unwrap();

		let mut reader = BufReader::new(file);
		let mut buf = String::new();
		reader.read_to_string(&mut buf).unwrap();

		let file_id = if let Some(file_id) = diagnostics.get_file_id(&full_path) {
			file_id
		} else {
			let file_id = diagnostics.id();
			diagnostics.insert_file_info(file_id, full_path);
			file_id
		};
		stack.push_lexer(Lexer::new(buf, file_id));
		vec![]
	},
};

TextLine: Vec<TokenTriple> = {
	"\n" => vec![],
	<nh:NonHash> <mut tokens: PreprocessingToken*> "\n" => {
		let mut result = vec![nh];
		result.append(&mut tokens);
		result
	},
};

PreprocessingToken: TokenTriple = {
	Ident,
	<lo:@L> <tk:PP_NUMBER> <hi:@R> =>? {
		let file_id = tk.file_id;
		match tk.kind.try_into() {
			Ok(kind) => Ok((
				lo,
				Token{
					kind,
					file_id,
				},
				hi
			)),
			Err(kind) => {
				eprintln!("pp-number error");
				Err(lalr::ParseError::User {
					error: diag::Diagnostic::error(
						kind,
						diag::Span {
							loc: (hi, lo),
							file_id: tk.file_id,
						},
					)
				})
			},
		}
	},
	<lo:@L> <tk:CHAR_CONST> <hi:@R> =>? {
		let file_id = tk.file_id;
		match tk.kind.try_into() {
			Ok(kind) => Ok((
				lo,
				Token{
					kind,
					file_id,
				},
				hi
			)),
			Err(kind) => Err(lalr::ParseError::User {
				error: diag::Diagnostic::error(
					kind,
					diag::Span {
						loc: (hi, lo),
						file_id: tk.file_id,
					},
				)
			}),
		}
	},
	StrLit => <>,
	<lo:@L> <tk:PUNCT> <hi:@R> =>? {
		let file_id = tk.file_id;
		match tk.kind.try_into() {
			Ok(kind) => Ok((
				lo,
				Token{
					kind,
					file_id,
				},
				hi
			)),
			Err(kind) => Err(lalr::ParseError::User {
				error: diag::Diagnostic::error(
					kind,
					diag::Span {
						loc: (hi, lo),
						file_id: tk.file_id,
					},
				)
			}),
		}
	}
};


DirectiveInclude: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "include", lo, hi);
DirectiveIf: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "if", lo, hi);
DirectiveIfdef: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "ifdef", lo, hi);
DirectiveIfndef: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "ifndef", lo, hi);
DirectiveElif: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "elif", lo, hi);
DirectiveElse: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "else", lo, hi);
DirectiveEndif: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "endif", lo, hi);
DirectiveDefine: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "define", lo, hi);
DirectiveUndef: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "undef", lo, hi);
DirectiveLine: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "line", lo, hi);
DirectiveError: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "error", lo, hi);
DirectivePragma: () = <lo:@L> <tk:IDENT> <hi:@R> =>? directive!(tk.kind, "pragma", lo, hi);


NonHash: TokenTriple = {
	Ident,
	StrLit,
	<lo:@L> <tk:NonHashPunct> <hi:@R> =>? {
		let file_id = tk.file_id;
		match tk.kind.try_into() {
			Ok(kind) => Ok((
				lo,
				Token{
					kind,
					file_id,
				},
				hi
			)),
			Err(kind) => Err(lalr::ParseError::User {
				error: diag::Diagnostic::error(
					kind,
					diag::Span {
						loc: (hi, lo),
						file_id: tk.file_id,
					},
				)
			}),
		}
	},
};

Ident: TokenTriple = <lo:@L> <tk:IDENT> <hi:@R> =>? {
	let file_id = tk.file_id;
	match tk.kind.try_into() {
		Ok(kind) => Ok((
			lo,
			Token{
				kind,
				file_id,
			},
			hi
		)),
		Err(kind) => Err(lalr::ParseError::User {
			error: diag::Diagnostic::error(
				kind,
				diag::Span {
					loc: (hi, lo),
					file_id: tk.file_id,
				},
			)
		}),
	}
};

StrLit: TokenTriple = <lo:@L> <tk:STR_LIT> <hi:@R> => {
	let file_id = tk.file_id;
	(
		lo,
		Token {
			kind: TokenKind::StrLit(tk.kind.unwrap_str_lit()),
			file_id,
		},
		hi
	)
};

PUNCT: PPToken = {
	"#",
	NonHashPunct,
};

NonHashPunct: PPToken = {
	"##",  "(", " (", ")",  "{",
	"}",   "*", "=",  ";",  ":",
	",",   "[", "]",  "?",  "~",
	"...", "+", "-",  "<<", ">>",
	"!",
};


extern {
	type Location = usize;
	type Error = diag::Diagnostic;

	enum PPToken {
		HEADER_NAME => PPToken{kind: PPTokenKind::HeaderName(_), ..},
		IDENT => PPToken{kind: PPTokenKind::Ident{..}, ..},
		PP_NUMBER => PPToken{kind: PPTokenKind::PPNumber(_), ..},
		CHAR_CONST => PPToken{kind: PPTokenKind::CharConst(_), ..},
		STR_LIT => PPToken{kind: PPTokenKind::StrLit(_), ..},
		"\n" => PPToken{kind: PPTokenKind::NewLine(_), ..},
		"#" => PPToken{kind: PPTokenKind::Punct(Punct::Hash), ..},
		"##" => PPToken{kind: PPTokenKind::Punct(Punct::HashHash), ..},
		"(" => PPToken{kind: PPTokenKind::Punct(Punct::LParen), leading_space: false, ..},
		" (" => PPToken{kind: PPTokenKind::Punct(Punct::LParen), leading_space: true, ..},
		")" => PPToken{kind: PPTokenKind::Punct(Punct::RParen), ..},
		"{" => PPToken{kind: PPTokenKind::Punct(Punct::LCurly), ..},
		"}" => PPToken{kind: PPTokenKind::Punct(Punct::RCurly), ..},
		"*" => PPToken{kind: PPTokenKind::Punct(Punct::Star), ..},
		"=" => PPToken{kind: PPTokenKind::Punct(Punct::Equal), ..},
		";" => PPToken{kind: PPTokenKind::Punct(Punct::SemiColon), ..},
		":" => PPToken{kind: PPTokenKind::Punct(Punct::Colon), ..},
		"," => PPToken{kind: PPTokenKind::Punct(Punct::Comma), ..},
		"[" => PPToken{kind: PPTokenKind::Punct(Punct::LSquare), ..},
		"]" => PPToken{kind: PPTokenKind::Punct(Punct::RSquare), ..},
		"?" => PPToken{kind: PPTokenKind::Punct(Punct::QMark), ..},
		"~" => PPToken{kind: PPTokenKind::Punct(Punct::Tilde), ..},
		"..." => PPToken{kind: PPTokenKind::Punct(Punct::Ellipsis), ..},
		"+" => PPToken{kind: PPTokenKind::Punct(Punct::Plus), ..},
		"-" => PPToken{kind: PPTokenKind::Punct(Punct::Minus), ..},
		"<<" => PPToken{kind: PPTokenKind::Punct(Punct::LessLess), ..},
		">>" => PPToken{kind: PPTokenKind::Punct(Punct::GreatGreat), ..},
		"!" => PPToken{kind: PPTokenKind::Punct(Punct::Bang), ..},
	}
}
