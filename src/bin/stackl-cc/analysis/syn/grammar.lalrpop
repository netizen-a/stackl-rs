use std::cell::RefCell;
use std::rc::Rc;
use crate::analysis::syn::*;
use crate::analysis::tok::*;
use crate::diagnostics as diag;
use lalrpop_util as lalr;


grammar<'a>(
	errors: &'a mut Vec<lalr::ErrorRecovery<usize, Token, diag::Diagnostic>>,
	tk_ref: &'a Rc<RefCell<InnerIter>>
);


// A.1.3 Identifiers

Identifier: Ident = IDENT => <>.kind.unwrap_ident();


// A.1.5 Constants

Constant: Const = CONST => <>.kind.unwrap_const();

EnumerationConstant: Ident = Identifier;


// A.1.6 String literals

StringLiteral: StrLit = <v:STR_LIT+> => string_concat(v.into_boxed_slice());


// A.2.1 Expressions

PrimaryExpr: Expr = {
	Identifier => Expr::Ident(<>),
	Constant => Expr::Const(<>),
	StringLiteral => Expr::StrLit(<>),
	"(" <expr:Expr> ")" => Expr::Paren(Box::new(expr)),
};

PostfixExpr: Expr = {
	PrimaryExpr,
	<expr:PostfixExpr> "[" <arr:Expr> "]" => Expr::Unary(ExprUnary{
		op: UnOp::Postfix(Postfix::Array(Box::new(arr))),
		expr: Box::new(expr),
	}),
	<expr:PostfixExpr> "(" <args:ArgumentExprList?> ")" => Expr::Unary(ExprUnary{
		op: UnOp::Postfix(Postfix::ArgExprList(args.unwrap_or_default())),
		expr: Box::new(expr),
	}),
	<expr:PostfixExpr> "." <ident:Identifier> => Expr::Unary(ExprUnary{
		op: UnOp::Postfix(Postfix::Dot(ident)),
		expr: Box::new(expr),
	}),
	<expr:PostfixExpr> "->" <ident:Identifier> => Expr::Unary(ExprUnary{
		op: UnOp::Postfix(Postfix::Arrow(ident)),
		expr: Box::new(expr),
	}),
	<expr:PostfixExpr> "++" => Expr::Unary(ExprUnary{
		op: UnOp::Postfix(Postfix::Inc),
		expr: Box::new(expr),
	}),
	<expr:PostfixExpr> "--" => Expr::Unary(ExprUnary{
		op: UnOp::Postfix(Postfix::Dec),
		expr: Box::new(expr),
	}),
	"(" <ty:TypeName> ")" "{" <list:InitializerList> ","? "}" => Expr::CompoundLiteral(ty, list),
};

ArgumentExprList: Vec<Expr> = {
	AssignmentExpr => vec![<>],
	<mut list:ArgumentExprList> "," <expr:AssignmentExpr> => {
		list.push(expr);
		list
	},
};

UnaryExpr: Expr = {
	PostfixExpr,
	"++" <expr:UnaryExpr> => Expr::Unary(ExprUnary{
		op: UnOp::Inc,
		expr: Box::new(expr),
	}),
	"--" <expr:UnaryExpr> => Expr::Unary(ExprUnary{
		op: UnOp::Dec,
		expr: Box::new(expr),
	}),
	<prefix:UnaryOperator> <expr:CastExpr> => Expr::Unary(ExprUnary{
		op: prefix,
		expr: Box::new(expr),
	}),
	"sizeof" <expr:UnaryExpr> => Expr::Unary(ExprUnary{
		op: UnOp::Sizeof,
		expr: Box::new(expr),
	}),
	"sizeof" "(" <ty:TypeName> ")" => Expr::Sizeof(ty),
};

UnaryOperator: UnOp = {
	"&" => UnOp::Amp,
	"*" => UnOp::Star,
	"+" => UnOp::Plus,
	"-" => UnOp::Minus,
	"~" => UnOp::Comp,
	"!" => UnOp::Neg,
};

CastExpr: Expr = {
	UnaryExpr,
	"(" <ty:TypeName> ")" <expr:CastExpr> => Expr::Unary(ExprUnary{
		op: UnOp::Cast(ty),
		expr: Box::new(expr),
	}),
};

MultiplicativeExpr: Expr = {
	CastExpr,
	<lhs:MultiplicativeExpr> "*" <rhs:CastExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Mul,
		right: Box::new(rhs),
	}),
	<lhs:MultiplicativeExpr> "/" <rhs:CastExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Div,
		right: Box::new(rhs),
	}),
	<lhs:MultiplicativeExpr> "%" <rhs:CastExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Mod,
		right: Box::new(rhs),
	}),
};

AdditiveExpr: Expr = {
	MultiplicativeExpr,
	<lhs:AdditiveExpr> "+" <rhs:MultiplicativeExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Add,
		right: Box::new(rhs)
	}),
	<lhs:AdditiveExpr> "-" <rhs:MultiplicativeExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Sub,
		right: Box::new(rhs),
	}),
};

ShiftExpr: Expr = {
	AdditiveExpr,
	<lhs:ShiftExpr> "<<" <rhs:AdditiveExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::LShift,
		right: Box::new(rhs),
	}),
	<lhs:ShiftExpr> ">>" <rhs:AdditiveExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::RShift,
		right: Box::new(rhs),
	}),
};

RelationalExpr: Expr = {
	ShiftExpr,
	<lhs:RelationalExpr> "<" <rhs:ShiftExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Less,
		right: Box::new(rhs),
	}),
	<lhs:RelationalExpr> ">" <rhs:ShiftExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Great,
		right: Box::new(rhs),
	}),
	<lhs:RelationalExpr> "<=" <rhs:ShiftExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::LessEqual,
		right: Box::new(rhs),
	}),
	<lhs:RelationalExpr> ">=" <rhs:ShiftExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::GreatEqual,
		right: Box::new(rhs),
	}),
};

EqualityExpr: Expr = {
	RelationalExpr,
	<lhs:EqualityExpr> "==" <rhs:RelationalExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Equal,
		right: Box::new(rhs),
	}),
	<lhs:EqualityExpr> "!=" <rhs:RelationalExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::NotEqual,
		right: Box::new(rhs),
	}),
};

AndExpr: Expr = {
	EqualityExpr,
	<lhs:AndExpr> "&" <rhs:EqualityExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::And,
		right: Box::new(rhs),
	}),
};

ExclusiveOrExpr: Expr = {
	AndExpr,
	<lhs:ExclusiveOrExpr> "^" <rhs:AndExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::XOr,
		right: Box::new(rhs),
	}),
};

InclusiveOrExpr: Expr = {
	ExclusiveOrExpr,
	<lhs:InclusiveOrExpr> "|" <rhs:ExclusiveOrExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Or,
		right: Box::new(rhs),
	}),
};

LogicalAndExpr: Expr = {
	InclusiveOrExpr,
	<lhs:LogicalAndExpr> "&&" <rhs:InclusiveOrExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::LogicalAnd,
		right: Box::new(rhs),
	}),
};

LogicalOrExpr: Expr = {
	LogicalAndExpr,
	<lhs:LogicalOrExpr> "||" <rhs:LogicalAndExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::XOr,
		right: Box::new(rhs),
	}),
};

ConditionalExpr: Expr = {
	LogicalOrExpr,
	LogicalOrExpr "?" Expr ":" ConditionalExpr => todo!(),
};

AssignmentExpr: Expr = {
	ConditionalExpr,
	<lhs:UnaryExpr> <op:AssignmentOperator> <rhs:AssignmentExpr> => {
		Expr::Binary(ExprBinary{
			left: Box::new(lhs),
			op: op,
			right: Box::new(rhs),
		})
	},
};

AssignmentOperator: BinOp = {
	"=" => BinOp::Assign,
	"*=" => BinOp::MulAssign,
	"/=" => BinOp::DivAssign,
	"%=" => BinOp::ModAssign,
	"+=" => BinOp::AddAssign,
	"-=" => BinOp::SubAssign,
	"<<=" => BinOp::LShiftAssign,
	">>=" => BinOp::RShiftAssign,
	"&=" => BinOp::AmpAssign,
	"^=" => BinOp::XOrAssign,
	"|=" => BinOp::OrAssign,
};

Expr: Expr = {
	AssignmentExpr,
	<lhs:Expr> "," <rhs:AssignmentExpr> => Expr::Binary(ExprBinary{
		left: Box::new(lhs),
		op: BinOp::Comma,
		right: Box::new(rhs),
	}),
};

ConstantExpr = ConditionalExpr;



// A.2.2 Declarations

Declaration: Declaration = {
	<kind_list:DeclarationSpecifier+> <init_list:InitDeclaratorList?> ";" =>? {
		tk_ref.borrow_mut().is_typedef = false;
		match DeclarationSpecifiers::try_from(kind_list) {
			Ok(specifiers) => Ok(Declaration {
				specifiers,
				init_declarator_list: init_list.unwrap_or_default(),
			}),
			Err(error) => Err(lalr::ParseError::User{error}),
		}
	},
};

DeclarationSpecifier: DeclSpecKind = {
	StorageClassSpecifier => DeclSpecKind::StorageClassSpecifier(<>),
	TypeSpecifier => DeclSpecKind::TypeSpecifier(<>),
	TypeQualifier => DeclSpecKind::TypeQualifier(<>),
	FunctionSpecifier => DeclSpecKind::FunctionSpecifier(<>),
};

InitDeclaratorList: Vec<InitDeclarator> = {
	InitDeclarator => vec![<>],
	<mut lhs:InitDeclaratorList> "," <rhs:InitDeclarator> => {
		lhs.push(rhs);
		lhs
	},
};

InitDeclarator: InitDeclarator = {
	<decl:Declarator> => InitDeclarator {
		identifier: decl.0,
		declarator: decl.1,
		initializer: None,
	},
	<decl:Declarator> "=" <init:Initializer> => InitDeclarator {
		identifier: decl.0,
		declarator: decl.1,
		initializer: Some(init)
	},
};

StorageClassSpecifier: StorageClassSpecifier = {
	<lo:@L> <kw:"typedef"> <hi:@R> => {
		tk_ref.borrow_mut().is_typedef = true;
		StorageClassSpecifier {
			span: diag::Span{
				loc: (lo,hi),
				file_id: kw.file_id,
			},
			keyword: Keyword::Typedef,
		}
	},
	<lo:@L> <kw:"extern"> <hi:@R> => StorageClassSpecifier {
		span: diag::Span{
			loc: (lo,hi),
			file_id: kw.file_id,
		},
		keyword: Keyword::Extern,
	},
	<lo:@L> <kw:"static"> <hi:@R> => StorageClassSpecifier {
		span: diag::Span{
			loc: (lo,hi),
			file_id: kw.file_id,
		},
		keyword: Keyword::Static,
	},
	<lo:@L> <kw:"auto"> <hi:@R> => StorageClassSpecifier {
		span: diag::Span{
			loc: (lo,hi),
			file_id: kw.file_id,
		},
		keyword: Keyword::Auto,
	},
	<lo:@L> <kw:"register"> <hi:@R> => StorageClassSpecifier {
		span: diag::Span{
			loc: (lo,hi),
			file_id: kw.file_id,
		},
		keyword: Keyword::Register,
	},
}

TypeSpecifier: TypeSpecifier = {
	<lo:@L> <kw:"void"> <hi:@R> => TypeSpecifier::Void(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"char"> <hi:@R> => TypeSpecifier::Char(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"short"> <hi:@R> => TypeSpecifier::Short(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"int"> <hi:@R> => TypeSpecifier::Int(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"long"> <hi:@R> => TypeSpecifier::Long(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"float"> <hi:@R> => TypeSpecifier::Float(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"double"> <hi:@R> => TypeSpecifier::Double(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"signed"> <hi:@R> => TypeSpecifier::Signed(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"unsigned"> <hi:@R> => TypeSpecifier::Unsigned(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	<lo:@L> <kw:"_Bool"> <hi:@R> => TypeSpecifier::Bool(diag::Span{
		loc: (lo,hi),
		file_id: kw.file_id,
	}),
	StructOrUnionSpecifier => TypeSpecifier::StructOrUnionSpecifier(<>),
	EnumSpecifier => TypeSpecifier::EnumSpecifier(<>),
	<lo:@L> <name:TYPE_NAME> <hi:@R> => TypeSpecifier::TypedefName{
		span: diag::Span{
			loc: (lo,hi),
			file_id: name.file_id,
		},
		name: name.kind.unwrap_ident()
	},
};

StructOrUnionSpecifier: StructOrUnionSpecifier = {
	<prefix:StructOrUnion> <ident:Identifier?> "{" <list:StructDeclaration+> "}" => StructOrUnionSpecifier {
		struct_or_union: prefix,
		ident,
		struct_declaration_list: list,
	},
	<prefix:StructOrUnion> <ident:Identifier> => StructOrUnionSpecifier {
		struct_or_union: prefix,
		ident: Some(ident),
		struct_declaration_list: vec![],
	},
};

StructOrUnion: StructOrUnion = {
	<lo:@L> <kw:"struct"> <hi:@R> => StructOrUnion{
		span: diag::Span{
			loc: (lo,hi),
			file_id: kw.file_id,
		},
		keyword: Keyword::Struct,
	},
	<lo:@L> <kw:"union"> <hi:@R> => StructOrUnion{
		span: diag::Span{
			loc: (lo,hi),
			file_id: kw.file_id,
		},
		keyword: Keyword::Union,
	},
};

StructDeclaration: StructDeclaration = {
	<list0:SpecifierQualifierList> <list1:StructDeclaratorList> ";" => StructDeclaration {
		specifier_qualifier_list: list0,
		struct_declaration_list: list1,
	}
};

SpecifierQualifierList: Vec<SpecifierQualifier> = SpecifierQualifier+;

SpecifierQualifier: SpecifierQualifier = {
	TypeSpecifier => SpecifierQualifier::TypeSpecifier(<>),
	TypeQualifier => SpecifierQualifier::TypeQualifier(<>),
};

StructDeclaratorList: Vec<StructDeclarator> = {
	StructDeclarator => vec![<>],
	<mut list:StructDeclaratorList> "," <elem:StructDeclarator> => {
		list.push(elem);
		list
	},
};

StructDeclarator: StructDeclarator = {
	<decl:Declarator> => StructDeclarator {
		identifier: Some(decl.0),
		declarator: decl.1,
		constant_expr: None,
	},
	<decl:Declarator?> ":" <expr:ConstantExpr> => StructDeclarator {
		identifier: decl.clone().map(|inner| inner.0),
		declarator: decl.map(|inner| inner.1).unwrap_or_default(),
		constant_expr: Some(expr),
	},
};

EnumSpecifier: EnumSpecifier = {
	"enum" <id:Identifier?> "{" <list:EnumeratorList> ","? "}" => {
		EnumSpecifier {
			identifier: id,
			enumerator_list: list,
		}
	},
	"enum" <id:Identifier> => EnumSpecifier{
		identifier: Some(id),
		enumerator_list: vec![],
	},
};

EnumeratorList: Vec<Enumerator> = {
	Enumerator => vec![<>],
	<mut list:EnumeratorList> "," <elem:Enumerator> => {
		list.push(elem);
		list
	},
};

Enumerator: Enumerator = {
	<ident:EnumerationConstant> => Enumerator {
		enumeration_constant: ident,
		constant_expr: None,
	},
	<ident:EnumerationConstant> "=" <expr:ConstantExpr> => Enumerator {
		enumeration_constant: ident,
		constant_expr: Some(expr),
	},
};

TypeQualifier: TypeQualifier = {
	<lo:@L> <kw:"const"> <hi:@R>    => TypeQualifier{
		span: diag::Span {loc: (lo, hi), file_id: kw.file_id},
		kind: TypeQualifierKind::Const,
	},
	<lo:@L> <kw:"restrict"> <hi:@R> => TypeQualifier{
		span: diag::Span {loc: (lo, hi), file_id: kw.file_id},
		kind: TypeQualifierKind::Restrict,
	},
	<lo:@L> <kw:"volatile"> <hi:@R> => TypeQualifier{
		span: diag::Span {loc: (lo, hi), file_id: kw.file_id},
		kind: TypeQualifierKind::Volatile,
	},
};

FunctionSpecifier: FunctionSpecifier = "inline" => FunctionSpecifier::Inline;

Declarator: (Ident, Vec<DirectDeclarator>) = {
	<ptr:Pointer?> <mut dd_list:DirectDeclaratorList> => {
		let mut ptr_list: Vec<DirectDeclarator> = ptr
			.unwrap_or_default()
			.into_iter()
			.map(DirectDeclarator::Pointer)
			.collect();
		dd_list.1.append(&mut ptr_list);
		dd_list
	},
};

DirectDeclaratorList: (Ident, Vec<DirectDeclarator>) = {
	<mut ident:Identifier> => {
		let mut tk_mut = tk_ref.borrow_mut();
		if tk_mut.is_typedef == true {
			ident.is_type = true;
			tk_mut.push_type(ident.clone());
		}
		(ident, vec![])
	},
	"(" <decl:Declarator> ")" => decl,
	<mut dd_list:DirectDeclaratorList> "[" <qual:TypeQualifier*> <expr:AssignmentExpr?> "]" => {
		dd_list.1.push(DirectDeclarator::Array{
			type_qualifier_list: qual,
			assignment_expr: expr,
			has_static: false,
			has_ptr: false,
		});
		dd_list
	},
	<mut dd_list:DirectDeclaratorList> "[" "static" <qual:TypeQualifier*> <expr:AssignmentExpr> "]" => {
		dd_list.1.push(DirectDeclarator::Array{
			type_qualifier_list: qual,
			assignment_expr: Some(expr),
			has_static: true,
			has_ptr: false,
		});
		dd_list
	},
	<mut dd_list:DirectDeclaratorList> "[" <qual:TypeQualifier+> "static" <expr:AssignmentExpr> "]" => {
		dd_list.1.push(DirectDeclarator::Array{
			type_qualifier_list: qual,
			assignment_expr: Some(expr),
			has_static: true,
			has_ptr: false,
		});
		dd_list
	},
	<mut dd_list:DirectDeclaratorList> "[" <qual:TypeQualifier*> "*" "]" => {
		dd_list.1.push(DirectDeclarator::Array{
			type_qualifier_list: qual,
			assignment_expr: None,
			has_static: false,
			has_ptr: true,
		});
		dd_list
	},
	<mut dd_list:DirectDeclaratorList> "(" <list: ParameterTypeList> ")" => {
		dd_list.1.push(DirectDeclarator::ParameterTypeList(list));
		dd_list
	},
	<mut dd_list:DirectDeclaratorList> "(" <ident_list:IdentifierList?> ")" => {
		dd_list.1.push(DirectDeclarator::IdentifierList(ident_list.unwrap_or_default()));
		dd_list
	},
};

Pointer: Vec<Pointer> = {
	"*" <type_qualifier_list:TypeQualifier*> => vec![Pointer::from(type_qualifier_list.as_slice())],
	"*" <type_qualifier_list:TypeQualifier*> <mut v:Pointer> => {
		v.push(Pointer::from(type_qualifier_list.as_slice()));
		v
	},
};
ParameterTypeList: ParameterTypeList = {
	ParameterList => ParameterTypeList {
		parameter_list: <>,
		is_variadic: false,
	},
	<parameter_list:ParameterList> "," "..." => ParameterTypeList {
		parameter_list,
		is_variadic: true,
	},
};

ParameterList: Vec<ParameterDeclaration> = {
	ParameterDeclaration => vec![<>],
	<mut v:ParameterList> "," <elem:ParameterDeclaration> => {
		v.push(elem);
		v
	},
};

ParameterDeclaration: ParameterDeclaration = {
	<kind_list:DeclarationSpecifier+> <decl:ParameterDeclarator> =>? {
		match DeclarationSpecifiers::try_from(kind_list) {
			Ok(specifiers) => Ok(ParameterDeclaration {
				name: decl.0,
				specifiers,
				parameter_declarator: decl.1,
			}),
			Err(error) => Err(lalr::ParseError::User{error}),
		}
	},
};

ParameterDeclarator: (Option<Ident>,ParameterDeclarator) = {
	Declarator => (Some(<>.0), ParameterDeclarator::Declarator(<>.1)),
	<decl:AbstractDeclarator?> => (None, ParameterDeclarator::AbstractDeclarator(decl)),
}

IdentifierList: Vec<Ident> = {
	Identifier => vec![<>],
	<mut v:IdentifierList> "," <elem:Identifier> => {
		v.push(elem);
		v
	},
};

TypeName: TypeName = {
	SpecifierQualifierList AbstractDeclarator? => todo!("specifier-qualifier-list abstract-declarator"),
};

AbstractDeclarator: AbstractDeclarator = {
	Pointer => todo!("ptr"),
	Pointer? DirectAbstractDeclarator => todo!("ptr direct"),
};


DirectAbstractDeclarator: DirectAbstractDeclarator = {
	"(" AbstractDeclarator ")" => todo!("abstract-decl"),
	DirectAbstractDeclarator? "[" AssignmentExpr? "]" => todo!("direct assign"),
	DirectAbstractDeclarator? "[" "*" "]" => todo!("direct *"),
	DirectAbstractDeclarator? "(" ParameterTypeList? ")" => todo!("direct param"),
};

Initializer: Initializer = {
	AssignmentExpr => Initializer::Expr(<>),
	"{" InitializerList ","? "}" => todo!("init-list"),
};

InitializerList: InitializerList = {
	Designation? Initializer => todo!("desig init"),
	InitializerList "," Designation? Initializer => todo!("init list , desig"),
};

Designation: Designation = {
	Designator+ "=" => todo!("desig list"),
};

Designator: Designator = {
	"[" ConstantExpr "]" => todo!("const-expr"),
	"." Identifier => todo!(" . identifier"),
};


// A.2.3 Statements

Statement: Stmt = {
	OpenedStatement,
	ClosedStatement,
};

OpenedStatement: Stmt = {
	"if" "(" Expr ")" OpenedStatement => todo!("opened-if"),
	"if" "(" Expr ")" ClosedStatement "else" OpenedStatement => todo!("opened-if-else"),
	"switch" "(" Expr ")" OpenedStatement => todo!("opened-switch"),
	OpenedLabeledStatement => todo!("opened-label"),
	OpenedCompoundStatement => todo!("opened-compound"),
	OpenedIterationStatement => todo!("opened-iter"),
};

ClosedStatement: Stmt = {
	SimpleStatement,
	"if" "(" Expr ")" ClosedStatement "else" ClosedStatement => todo!("closed-if"),
	"switch" "(" Expr ")" ClosedStatement => todo!("closed-switch"),
	ClosedLabeledStatement => todo!("closed-label"),
	ClosedCompoundStatement => Stmt::Compound(<>),
	ClosedIterationStatement => todo!("closed-iter"),
};

SimpleStatement: Stmt = {
	ExprStatement => Stmt::Expr(<>),
	JumpStatement => Stmt::Jump(<>),
	AsmStatement => Stmt::Asm(<>),
};


OpenedLabeledStatement: LabeledStmt = {
	Identifier ":" OpenedStatement => todo!("label"),
	"case" ConstantExpr ":" OpenedStatement => todo!("case"),
	"default" ":" OpenedStatement => todo!("default"),
};

ClosedLabeledStatement: LabeledStmt = {
	Identifier ":" ClosedStatement => todo!("label"),
	"case" ConstantExpr ":" ClosedStatement => todo!("case"),
	"default" ":" ClosedStatement => todo!("default"),
};


OpenedCompoundStatement: CompoundStmt = {
	IncScope <blocks:OpenedBlockItem*> DecScope => CompoundStmt(blocks),
};

ClosedCompoundStatement: CompoundStmt = {
	IncScope <blocks:ClosedBlockItem*> DecScope => CompoundStmt(blocks),
};

IncScope: () = "{" => {
	tk_ref.borrow_mut().increase_scope();
};

DecScope: () = "}" => {
	tk_ref.borrow_mut().decrease_scope();
};


OpenedBlockItem: BlockItem = {
	Declaration => BlockItem::Declaration(<>),
	OpenedStatement => BlockItem::Statement(<>),
	! => { errors.push(<>); BlockItem::Error },
};
ClosedBlockItem: BlockItem = {
	Declaration => BlockItem::Declaration(<>),
	ClosedStatement => BlockItem::Statement(<>),
	! => { errors.push(<>); BlockItem::Error },
};

ExprStatement: ExprStmt = <expr:Expr?> ";" => ExprStmt(expr);

ClosedIterationStatement: IterStmt = {
	"while" "(" Expr ")" ClosedStatement => todo!(),
	"do" ClosedStatement "while" "(" Expr ")" ";"
	"for" "(" Expr? ";" Expr? ";" Expr? ")" ClosedStatement => todo!(),
	"for" "(" Declaration Expr? ";" Expr? ")" ClosedStatement => todo!(),
};
OpenedIterationStatement: IterStmt = {
	"while" "(" Expr ")" OpenedStatement => todo!(),
	"do" OpenedStatement "while" "(" Expr ")" ";"
	"for" "(" Expr? ";" Expr? ";" Expr? ")" OpenedStatement => todo!(),
	"for" "(" Declaration Expr? ";" Expr? ")" OpenedStatement => todo!(),
};

JumpStatement: JumpStmt = {
	"goto" <ident:Identifier> ";" => JumpStmt::Goto(ident),
	"continue" ";" => JumpStmt::Continue,
	"break" ";" => JumpStmt::Break,
	"return" <expr:Expr?> ";" => JumpStmt::Return(expr),
};

AsmStatement: AsmStmt = {
	"asm" <q:AsmQualifiers?> "(" <template:StringLiteral>
		<constraints:AsmOptionalConstraintList?> ")" ";"
		=> AsmStmt{qualifiers: q.unwrap_or_default(), template, constraints},
};

AsmQualifiers: Vec<AsmQualifier> = {
	AsmQualifier => vec![<>],
	<mut v:AsmQualifiers> <elem:AsmQualifier> => {
		v.push(elem);
		v
	},
};

AsmQualifier: AsmQualifier = {
	"volatile" => AsmQualifier::Volatile,
	"inline" => AsmQualifier::Inline,
	"goto" => AsmQualifier::Goto,
};

AsmOptionalConstraintList: AsmConstraints = AsmOutput;
AsmOutput: AsmConstraints = ":" <operands:AsmOutputOperand*> <input:AsmInput?> => {
	match input {
		Some(mut inner) => {
			inner.output_operands = operands;
			inner
		},
		None => AsmConstraints {
			output_operands: operands,
			input_operands: Vec::new(),
			clobber_operands: Vec::new(),
			goto_labels: Vec::new(),
		}
	}
};
AsmInput: AsmConstraints = ":" <operands:AsmInputOperand*> <clobber:AsmClobber?> => {
	match clobber {
		Some(mut inner) => {
			inner.input_operands = operands;
			inner
		},
		None => AsmConstraints {
			output_operands: Vec::new(),
			input_operands: operands,
			clobber_operands: Vec::new(),
			goto_labels: Vec::new(),
		}
	}
};
AsmClobber: AsmConstraints = ":" <operands: StringLiteralList?> <labels: AsmGotoLabels?> => {
	match labels {
		Some(mut inner) => {
			inner.clobber_operands = operands.unwrap_or_default();
			inner
		},
		None => AsmConstraints {
			output_operands: Vec::new(),
			input_operands: Vec::new(),
			clobber_operands: operands.unwrap_or_default(),
			goto_labels: Vec::new(),
		}
	}
};
AsmGotoLabels: AsmConstraints = ":" <labels: IdentifierList?> => AsmConstraints {
	output_operands: Vec::new(),
	input_operands: Vec::new(),
	clobber_operands: Vec::new(),
	goto_labels: labels.unwrap_or_default(),
};

AsmOutputOperand: OutputOperand = <prefix: StringLiteral> "(" <ident:Identifier> ")"
	=> OutputOperand {prefix, ident};
AsmInputOperand: InputOperand = <prefix:StringLiteral> "(" <expr:Expr> ")"
	=> InputOperand{prefix, expr};


StringLiteralList: Vec<StrLit> = {
	StringLiteral => vec![<>],
	StringLiteralList "," StringLiteral => todo!("string-list"),
};


// A.2.4 External definitions

pub Syntax: TranslationUnit = ExternalDeclaration+;

ExternalDeclaration: ExternalDeclaration = {
	FunctionDefinition => ExternalDeclaration::FunctionDefinition(<>),
	Declaration => ExternalDeclaration::Declaration(<>),
	AsmStatement => ExternalDeclaration::Asm(<>),
	! => { errors.push(<>); ExternalDeclaration::Error },
};

FunctionDefinition: FunctionDefinition = {
	<kind_list: DeclarationSpecifier+> <decl:Declarator> <list:Declaration*> <compound:ClosedCompoundStatement> =>? {
		match DeclarationSpecifiers::try_from(kind_list) {
			Ok(specifiers) => Ok(FunctionDefinition {
				specifiers,
				declarator: decl.1,
				declaration_list: list,
				compound_stmt: compound,
			}),
			Err(error) => Err(lalr::ParseError::User{error}),
		}
	},
};

extern {
	type Location = usize;
	type Error = diag::Diagnostic;

	enum Token {
		IDENT => Token{kind: TokenKind::Ident(Ident{is_type:false, ..}), ..},
		TYPE_NAME => Token{kind: TokenKind::Ident(Ident{is_type:true, ..}), ..},
		CONST => Token{kind: TokenKind::Const(_), ..},
		STR_LIT => Token{kind: TokenKind::StrLit(_), ..},

		"typedef" => Token{kind: TokenKind::Keyword(Keyword::Typedef), ..},
		"extern" => Token{kind: TokenKind::Keyword(Keyword::Extern), ..},
		"static" => Token{kind: TokenKind::Keyword(Keyword::Static), ..},
		"auto" => Token{kind: TokenKind::Keyword(Keyword::Auto), ..},
		"register" => Token{kind: TokenKind::Keyword(Keyword::Register), ..},
		"void" => Token{kind: TokenKind::Keyword(Keyword::Void), ..},
		"char" => Token{kind: TokenKind::Keyword(Keyword::Char), ..},
		"short" => Token{kind: TokenKind::Keyword(Keyword::Short), ..},
		"int" => Token{kind: TokenKind::Keyword(Keyword::Int), ..},
		"long" => Token{kind: TokenKind::Keyword(Keyword::Long), ..},
		"float" => Token{kind: TokenKind::Keyword(Keyword::Float), ..},
		"double" => Token{kind: TokenKind::Keyword(Keyword::Double), ..},
		"signed" => Token{kind: TokenKind::Keyword(Keyword::Signed), ..},
		"unsigned" => Token{kind: TokenKind::Keyword(Keyword::Unsigned), ..},
		"_Bool" => Token{kind: TokenKind::Keyword(Keyword::Bool), ..},
		"const" => Token{kind: TokenKind::Keyword(Keyword::Const), ..},
		"restrict" => Token{kind: TokenKind::Keyword(Keyword::Restrict), ..},
		"volatile" => Token{kind: TokenKind::Keyword(Keyword::Volatile), ..},
		"enum" => Token{kind: TokenKind::Keyword(Keyword::Enum), ..},
		"struct" => Token{kind: TokenKind::Keyword(Keyword::Struct), ..},
		"sizeof" => Token{kind: TokenKind::Keyword(Keyword::Sizeof), ..},
		"union" => Token{kind: TokenKind::Keyword(Keyword::Union), ..},
		"inline" => Token{kind: TokenKind::Keyword(Keyword::Inline), ..},
		"case" => Token{kind: TokenKind::Keyword(Keyword::Case), ..},
		"default" => Token{kind: TokenKind::Keyword(Keyword::Default), ..},
		"if" => Token{kind: TokenKind::Keyword(Keyword::If), ..},
		"switch" => Token{kind: TokenKind::Keyword(Keyword::Switch), ..},
		"while" => Token{kind: TokenKind::Keyword(Keyword::While), ..},
		"do" => Token{kind: TokenKind::Keyword(Keyword::Do), ..},
		"for" => Token{kind: TokenKind::Keyword(Keyword::For), ..},
		"goto" => Token{kind: TokenKind::Keyword(Keyword::Goto), ..},
		"continue" => Token{kind: TokenKind::Keyword(Keyword::Continue), ..},
		"break" => Token{kind: TokenKind::Keyword(Keyword::Break), ..},
		"return" => Token{kind: TokenKind::Keyword(Keyword::Return), ..},
		"else" => Token{kind: TokenKind::Keyword(Keyword::Else), ..},
		"asm" => Token{kind: TokenKind::Keyword(Keyword::Asm), ..},

		"." => Token{kind: TokenKind::Punct(Punct::Dot), ..},
		"..." => Token{kind: TokenKind::Punct(Punct::Ellipsis), ..},
		"," => Token{kind: TokenKind::Punct(Punct::Comma), ..},
		"=" => Token{kind: TokenKind::Punct(Punct::Equal), ..},
		"*" => Token{kind: TokenKind::Punct(Punct::Star), ..},
		"+" => Token{kind: TokenKind::Punct(Punct::Plus), ..},
		"-" => Token{kind: TokenKind::Punct(Punct::Minus), ..},
		"~" => Token{kind: TokenKind::Punct(Punct::Tilde), ..},
		";" => Token{kind: TokenKind::Punct(Punct::SemiColon), ..},
		"{" => Token{kind: TokenKind::Punct(Punct::LCurly), ..},
		"}" => Token{kind: TokenKind::Punct(Punct::RCurly), ..},
		"(" => Token{kind: TokenKind::Punct(Punct::LParen), ..},
		")" => Token{kind: TokenKind::Punct(Punct::RParen), ..},
		")" => Token{kind: TokenKind::Punct(Punct::RParen), ..},
		"[" => Token{kind: TokenKind::Punct(Punct::LSquare), ..},
		"]" => Token{kind: TokenKind::Punct(Punct::RSquare), ..},
		"->" => Token{kind: TokenKind::Punct(Punct::Arrow), ..},
		"++" => Token{kind: TokenKind::Punct(Punct::PlusPlus), ..},
		"--" => Token{kind: TokenKind::Punct(Punct::MinusMinus), ..},
		"&" => Token{kind: TokenKind::Punct(Punct::Amp), ..},
		"!" => Token{kind: TokenKind::Punct(Punct::Bang), ..},
		"/" => Token{kind: TokenKind::Punct(Punct::FSlash), ..},
		"%" => Token{kind: TokenKind::Punct(Punct::Percent), ..},
		"<<" => Token{kind: TokenKind::Punct(Punct::LessLess), ..},
		">>" => Token{kind: TokenKind::Punct(Punct::GreatGreat), ..},
		"<" => Token{kind: TokenKind::Punct(Punct::Less), ..},
		">" => Token{kind: TokenKind::Punct(Punct::Amp), ..},
		"<=" => Token{kind: TokenKind::Punct(Punct::LessEqual), ..},
		">=" => Token{kind: TokenKind::Punct(Punct::GreatEqual), ..},
		"==" => Token{kind: TokenKind::Punct(Punct::EqualEqual), ..},
		"!=" => Token{kind: TokenKind::Punct(Punct::BangEqual), ..},
		"^" => Token{kind: TokenKind::Punct(Punct::Caret), ..},
		"|" => Token{kind: TokenKind::Punct(Punct::VBar), ..},
		"&&" => Token{kind: TokenKind::Punct(Punct::AmpAmp), ..},
		"||" => Token{kind: TokenKind::Punct(Punct::VBarVBar), ..},
		"?" => Token{kind: TokenKind::Punct(Punct::QMark), ..},
		":" => Token{kind: TokenKind::Punct(Punct::Colon), ..},
		"*=" => Token{kind: TokenKind::Punct(Punct::StarEqual), ..},
		"/=" => Token{kind: TokenKind::Punct(Punct::FSlashEqual), ..},
		"%=" => Token{kind: TokenKind::Punct(Punct::PercentEqual), ..},
		"+=" => Token{kind: TokenKind::Punct(Punct::PlusEqual), ..},
		"-=" => Token{kind: TokenKind::Punct(Punct::MinusEqual), ..},
		"<<=" => Token{kind: TokenKind::Punct(Punct::LessLessEqual), ..},
		">>=" => Token{kind: TokenKind::Punct(Punct::GreatGreatEqual), ..},
		"&=" => Token{kind: TokenKind::Punct(Punct::AmpEqual), ..},
		"^=" => Token{kind: TokenKind::Punct(Punct::CaretEqual), ..},
		"|=" => Token{kind: TokenKind::Punct(Punct::VBarEqual), ..},
	}
}
