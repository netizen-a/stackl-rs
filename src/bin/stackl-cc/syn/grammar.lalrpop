use crate::syn::*;
use crate::tok::*;

use crate::diag::syn::Error as SyntaxError;

grammar;

/*
// A.1.5 Constants

EnumerationConstant: Ident = IDENT => <>;


// A.2.1 Expressions

PrimaryExpression: PrimaryExpression = {
	IDENT => todo!(),
	CONST => todo!(),
	STR_LIT => todo!(),
	"(" Expression ")" => todo!(),
};

PostfixExpression: PostfixExpression = {
	PrimaryExpression => todo!(),
	PostfixExpression "[" Expression "]" => todo!(),
	PostfixExpression "(" ArgumentExpressionList? ")" => todo!(),
	PostfixExpression "." IDENT => todo!(),
	PostfixExpression "->" IDENT => todo!(),
	PostfixExpression "++" => todo!(),
	PostfixExpression "--" => todo!(),
	"(" TypeName ")" "{" InitializerList ","? "}" => todo!(),
};

ArgumentExpressionList: ArgumentExpressionList = {
	AssignmentExpression => vec![<>],
	ArgumentExpressionList "," AssignmentExpression => todo!(),
};

UnaryExpression: UnaryExpression = {
	PostfixExpression => todo!(),
	"++" UnaryExpression => todo!(),
	"--" UnaryExpression => todo!(),
	UnaryOperator CastExpression => todo!(),
	"sizeof" UnaryExpression => todo!(),
	"sizeof" "(" TypeName ")" => todo!(),
};

UnaryOperator: UnaryOperator = {
	"&" => todo!(),
	"*" => todo!(),
	"+" => todo!(),
	"-" => todo!(),
	"~" => todo!(),
	"!" => todo!(),
};

CastExpression: CastExpression = {
	UnaryExpression => todo!(),
	"(" TypeName ")" CastExpression => todo!(),
};

MultiplicativeExpression: MultiplicativeExpression = {
	CastExpression => todo!(),
	MultiplicativeExpression "*" CastExpression => todo!(),
	MultiplicativeExpression "/" CastExpression => todo!(),
	MultiplicativeExpression "%" CastExpression => todo!(),
};

AdditiveExpression: AdditiveExpression = {
	MultiplicativeExpression => todo!(),
	AdditiveExpression "+" MultiplicativeExpression => todo!(),
	AdditiveExpression "-" MultiplicativeExpression => todo!(),
};

ShiftExpression: ShiftExpression = {
	AdditiveExpression => todo!(),
	ShiftExpression "<<" AdditiveExpression => todo!(),
	ShiftExpression ">>" AdditiveExpression => todo!(),
};

RelationalExpression: RelationalExpression = {
	ShiftExpression => todo!(),
	RelationalExpression "<" ShiftExpression => todo!(),
	RelationalExpression ">" ShiftExpression => todo!(),
	RelationalExpression "<=" ShiftExpression => todo!(),
	RelationalExpression ">=" ShiftExpression => todo!(),
};

EqualityExpression: EqualityExpression = {
	RelationalExpression => todo!(),
	EqualityExpression "==" RelationalExpression => todo!(),
	EqualityExpression "!=" RelationalExpression => todo!(),
};

AndExpression: AndExpression = {
	EqualityExpression => todo!(),
	AndExpression "&" EqualityExpression => todo!(),
};

ExclusiveOrExpression: ExclusiveOrExpression = {
	AndExpression => todo!(),
	ExclusiveOrExpression "^" AndExpression => todo!(),
};

InclusiveOrExpression: InclusiveOrExpression = {
	ExclusiveOrExpression => todo!(),
	InclusiveOrExpression "|" ExclusiveOrExpression => todo!(),
};

LogicalAndExpression: LogicalAndExpression = {
	InclusiveOrExpression => todo!(),
	LogicalAndExpression "&&" InclusiveOrExpression => todo!(),
};

LogicalOrExpression: LogicalOrExpression = {
	LogicalAndExpression => todo!(),
	LogicalOrExpression "||" LogicalAndExpression => todo!(),
};

ConditionalExpression: ConditionalExpression = {
	LogicalOrExpression => todo!(),
	LogicalOrExpression "?" Expression ":" ConditionalExpression => todo!(),
};

AssignmentExpression: AssignmentExpression = {
	ConditionalExpression => todo!(),
	UnaryExpression AssignmentOperator AssignmentExpression => todo!(),
};

AssignmentOperator: AssignmentOperator = {
	"=" => todo!(),
	"*=" => todo!(),
	"/=" => todo!(),
	"%=" => todo!(),
	"+=" => todo!(),
	"-=" => todo!(),
	"<<=" => todo!(),
	">>=" => todo!(),
	"&=" => todo!(),
	"^=" => todo!(),
	"|=" => todo!(),
};

Expression: Expression = {
	AssignmentExpression => todo!(),
	Expression "," AssignmentExpression => todo!(),
};

ConstantExpression: ConstantExpression = {
	ConditionalExpression => todo!(),
};



// A.2.2 Declarations
*/
Declaration: Declaration = {
	DeclarationSpecifiers InitDeclaratorList? ";" => todo!(),
};

DeclarationSpecifiers: Vec<DeclarationSpecifier> = DeclarationSpecifier+ => <>;

DeclarationSpecifier: DeclarationSpecifier = {
	StorageClassSpecifier => todo!(),
	// TypeSpecifier => todo!(),
	// TypeQualifier => todo!(),
	// FunctionSpecifier => todo!(),
};

InitDeclaratorList: Vec<InitDeclarator> = {
	InitDeclarator => vec![<>],
	InitDeclaratorList "," InitDeclarator => todo!(),
};

InitDeclarator: InitDeclarator = {
	Declarator => todo!(),
	Declarator "=" Initializer => todo!(),
};

StorageClassSpecifier: Keyword = {
	"typedef" => todo!(),
	"extern" => todo!(),
	"static" => todo!(),
	"auto" => todo!(),
	"register" => todo!(),
}
/*
TypeSpecifier: TypeSpecifier = {
	"void" => todo!(),
	"char" => todo!(),
	"short" => todo!(),
	"int" => todo!(),
	"long" => todo!(),
	"float" => todo!(),
	"double" => todo!(),
	"signed" => todo!(),
	"unsigned" => todo!(),
	"_Bool" => todo!(),
	StructOrUnionSpecifier => todo!(),
	EnumSpecifier => todo!(),
	TypedefName => todo!(),
};

StructOrUnionSpecifier: StructOrUnionSpecifier = {
	StructOrUnion IDENT? "{" StructDeclarationList "}" => todo!(),
	StructOrUnion IDENT => todo!(),
};

StructOrUnion: Keyword = {
	"struct" => todo!(),
	"union" => todo!(),
};

StructDeclarationList: StructDeclarationList = StructDeclaration+ => todo!();

StructDeclaration: StructDeclaration = {
	SpecifierQualifierList StructDeclaratorList ";" => todo!(),
};

SpecifierQualifierList: Vec<SpecifierQualifier> = SpecifierQualifier+ => <>;

SpecifierQualifier: SpecifierQualifier = {
	TypeSpecifier => todo!(),
	TypeQualifier => todo!(),
};

StructDeclaratorList: Vec<StructDeclarator> = {
	StructDeclarator => vec![<>],
	StructDeclaratorList "," StructDeclarator => todo!(),
};

StructDeclarator: StructDeclarator = {
	Declarator => todo!(),
	Declarator? ":" ConstantExpression => todo!(),
};

EnumSpecifier: EnumSpecifier = {
	"enum" IDENT? "{" EnumeratorList ","? "}" => todo!(),
	"enum" IDENT => todo!(),
};

EnumeratorList: Vec<Enumerator> = {
	Enumerator => vec![<>],
	EnumeratorList "," Enumerator => todo!(),
};

Enumerator: Enumerator = {
	EnumerationConstant => todo!(),
	EnumerationConstant "=" ConstantExpression => todo!(),
};
*/
TypeQualifier: Keyword = {
	"const" => todo!(),
	"restrict" => todo!(),
	"volatile" => todo!(),
};
/*
FunctionSpecifier: Keyword = "inline" => <>;
*/
Declarator: Declarator = {
	Pointer? DirectDeclarator => todo!(),
};

DirectDeclarator: DirectDeclarator = {
	IDENT => todo!(),
	"(" Declarator ")" => todo!(),
	// DirectDeclarator "[" TypeQualifier* AssignmentExpression? "]" => todo!(),
	// DirectDeclarator "[" "static" TypeQualifier* AssignmentExpression "]" => todo!(),
	// DirectDeclarator "[" TypeQualifier+ "static" AssignmentExpression "]" => todo!(),
	// DirectDeclarator "[" TypeQualifier* "*" "]" => todo!(),
	// DirectDeclarator "(" ParameterTypeList ")" => todo!(),
	// DirectDeclarator "(" IdentifierList? ")" => todo!(),
};

Pointer: Pointer = {
	"*" TypeQualifier* => todo!(),
	"*" TypeQualifier* Pointer => todo!(),
};
/*
ParameterTypeList: ParameterTypeList = {
	ParameterList => todo!(),
	ParameterList "," "..." => todo!(),
};

ParameterList: Vec<ParameterDeclaration> = {
	ParameterDeclaration => vec![<>],
	ParameterList "," ParameterDeclaration => todo!(),
};

ParameterDeclaration: ParameterDeclaration = {
	DeclarationSpecifiers Declarator => todo!(),
	DeclarationSpecifiers AbstractDeclarator? => todo!(),
};

IdentifierList: Vec<Ident> = {
	IDENT => vec![<>],
	IdentifierList "," IDENT => todo!(),
};

TypeName: TypeName = {
	SpecifierQualifierList AbstractDeclarator? => todo!(),
};

AbstractDeclarator: AbstractDeclarator = {
	Pointer => todo!(),
	Pointer? DirectAbstractDeclarator => todo!(),
};

DirectAbstractDeclarator: DirectAbstractDeclarator = {
	"(" AbstractDeclarator ")" => todo!(),
	DirectAbstractDeclarator? "[" AssignmentExpression? "]" => todo!(),
	DirectAbstractDeclarator? "[" "*" "]" => todo!(),
	DirectAbstractDeclarator? "(" ParameterTypeList? ")" => todo!(),
};

TypedefName: Ident = IDENT => <>;
*/

Initializer: Initializer = {
	// AssignmentExpression => todo!(),
	"{" InitializerList ","? "}" => todo!(),
};

InitializerList: InitializerList = {
	Designation? Initializer => todo!(),
	InitializerList "," Designation? Initializer => todo!(),
};

Designation: Designation = {
	DesignatorList "=" => todo!(),
};

DesignatorList: DesignatorList = {
	Designator+ => todo!(),
};

Designator: Designator = {
	// "[" ConstantExpression "]" => todo!(),
	"." IDENT => todo!(),
};

/*

// A.2.3 Statements

Statement: Statement = {
	LabeledStatement => todo!(),
	CompoundStatement => todo!(),
	ExpressionStatement => todo!(),
	SelectionStatement => todo!(),
	IterationStatement => todo!(),
	JumpStatement => todo!(),
};

LabeledStatement: LabeledStatement = {
	IDENT ":" Statement => todo!(),
	"case" ConstantExpression ":" Statement => todo!(),
	"default" ":" Statement => todo!(),
};

CompoundStatement: CompoundStatement = {
	"{" BlockItem* "}" => todo!(),
};

BlockItem: BlockItem = {
	Declaration => todo!(),
	Statement => todo!(),
};

ExpressionStatement: ExpressionStatement = {
	Expression? ";" => todo!(),
};

SelectionStatement: SelectionStatement = {
	"if" "(" Expression ")" Statement => todo!(),
	"if" "(" Expression ")" Statement => "else" Statement => todo!(),
	"switch" "(" Expression ")" Statement => todo!(),
};

IterationStatement: IterationStatment = {
	"while" "(" Expression ")" Statement => todo!(),
	"do" Statement "while" "(" Expression ")" ";"
	"for" "(" Expression? ";" Expression? ";" Expression? ")" Statement => todo!(),
	"for" "(" Declaration Expression? ";" Expression? ")" Statement => todo!(),
};

JumpStatement: JumpStatment = {
	"goto" IDENT ";" => todo!(),
	"continue" ";" => todo!(),
	"break" ";" => todo!(),
	"return" Expression? ";" => todo!(),
};
*/

// A.2.4 External definitions

pub TranslationUnit: TranslationUnit = ExternalDeclaration+ => {
	TranslationUnit {
		external_declaration: <>,
	}
};

ExternalDeclaration: ExternalDeclaration = {
	// FunctionDefinition => ExternalDeclaration::FunctionDefinition(<>),
	Declaration => ExternalDeclaration::Declaration(<>),
};

/*
FunctionDefinition: FunctionDefinition = {
	DeclarationSpecifiers Declarator DeclarationList? CompoundStatement => todo!(),
};

DeclarationList: Vec<Declaration> = Declaration+ => <>;
*/

extern {
	type Location = usize;
	type Error = SyntaxError;

	enum Token {
		IDENT => Token{kind: TokenKind::Ident(_), ..},
		CONST => Token{kind: TokenKind::Const(_), ..},
		STR_LIT => Token{kind: TokenKind::StrLit(_), ..},

		"typedef" => Token{kind: TokenKind::Keyword(Keyword::Typedef), ..},
		"extern" => Token{kind: TokenKind::Keyword(Keyword::Extern), ..},
		"static" => Token{kind: TokenKind::Keyword(Keyword::Static), ..},
		"auto" => Token{kind: TokenKind::Keyword(Keyword::Auto), ..},
		"register" => Token{kind: TokenKind::Keyword(Keyword::Register), ..},
		"void" => Token{kind: TokenKind::Keyword(Keyword::Void), ..},
		"char" => Token{kind: TokenKind::Keyword(Keyword::Char), ..},
		"short" => Token{kind: TokenKind::Keyword(Keyword::Short), ..},
		"int" => Token{kind: TokenKind::Keyword(Keyword::Int), ..},
		"long" => Token{kind: TokenKind::Keyword(Keyword::Long), ..},
		"float" => Token{kind: TokenKind::Keyword(Keyword::Float), ..},
		"double" => Token{kind: TokenKind::Keyword(Keyword::Double), ..},
		"signed" => Token{kind: TokenKind::Keyword(Keyword::Signed), ..},
		"unsigned" => Token{kind: TokenKind::Keyword(Keyword::Unsigned), ..},
		"_Bool" => Token{kind: TokenKind::Keyword(Keyword::Bool), ..},
		"const" => Token{kind: TokenKind::Keyword(Keyword::Const), ..},
		"restrict" => Token{kind: TokenKind::Keyword(Keyword::Restrict), ..},
		"volatile" => Token{kind: TokenKind::Keyword(Keyword::Volatile), ..},
		"enum" => Token{kind: TokenKind::Keyword(Keyword::Enum), ..},
		"struct" => Token{kind: TokenKind::Keyword(Keyword::Struct), ..},
		"sizeof" => Token{kind: TokenKind::Keyword(Keyword::Sizeof), ..},
		"union" => Token{kind: TokenKind::Keyword(Keyword::Union), ..},
		"inline" => Token{kind: TokenKind::Keyword(Keyword::Inline), ..},
		"case" => Token{kind: TokenKind::Keyword(Keyword::Case), ..},
		"default" => Token{kind: TokenKind::Keyword(Keyword::Default), ..},
		"if" => Token{kind: TokenKind::Keyword(Keyword::If), ..},
		"switch" => Token{kind: TokenKind::Keyword(Keyword::Switch), ..},
		"while" => Token{kind: TokenKind::Keyword(Keyword::While), ..},
		"do" => Token{kind: TokenKind::Keyword(Keyword::Do), ..},
		"for" => Token{kind: TokenKind::Keyword(Keyword::For), ..},
		"goto" => Token{kind: TokenKind::Keyword(Keyword::Goto), ..},
		"continue" => Token{kind: TokenKind::Keyword(Keyword::Continue), ..},
		"break" => Token{kind: TokenKind::Keyword(Keyword::Break), ..},
		"return" => Token{kind: TokenKind::Keyword(Keyword::Return), ..},

		"." => Token{kind: TokenKind::Punct(Punct::Dot), ..},
		"..." => Token{kind: TokenKind::Punct(Punct::Ellipsis), ..},
		"," => Token{kind: TokenKind::Punct(Punct::Comma), ..},
		"=" => Token{kind: TokenKind::Punct(Punct::Equal), ..},
		"*" => Token{kind: TokenKind::Punct(Punct::Star), ..},
		"+" => Token{kind: TokenKind::Punct(Punct::Plus), ..},
		"-" => Token{kind: TokenKind::Punct(Punct::Minus), ..},
		"~" => Token{kind: TokenKind::Punct(Punct::Tilde), ..},
		";" => Token{kind: TokenKind::Punct(Punct::SemiColon), ..},
		"{" => Token{kind: TokenKind::Punct(Punct::LCurly), ..},
		"}" => Token{kind: TokenKind::Punct(Punct::RCurly), ..},
		"(" => Token{kind: TokenKind::Punct(Punct::LParen), ..},
		")" => Token{kind: TokenKind::Punct(Punct::RParen), ..},
		")" => Token{kind: TokenKind::Punct(Punct::RParen), ..},
		"[" => Token{kind: TokenKind::Punct(Punct::LSquare), ..},
		"]" => Token{kind: TokenKind::Punct(Punct::RSquare), ..},
		"->" => Token{kind: TokenKind::Punct(Punct::Arrow), ..},
		"++" => Token{kind: TokenKind::Punct(Punct::PlusPlus), ..},
		"--" => Token{kind: TokenKind::Punct(Punct::MinusMinus), ..},
		"&" => Token{kind: TokenKind::Punct(Punct::Amp), ..},
		"!" => Token{kind: TokenKind::Punct(Punct::Bang), ..},
		"/" => Token{kind: TokenKind::Punct(Punct::FSlash), ..},
		"%" => Token{kind: TokenKind::Punct(Punct::Percent), ..},
		"<<" => Token{kind: TokenKind::Punct(Punct::LessLess), ..},
		">>" => Token{kind: TokenKind::Punct(Punct::GreatGreat), ..},
		"<" => Token{kind: TokenKind::Punct(Punct::Less), ..},
		">" => Token{kind: TokenKind::Punct(Punct::Amp), ..},
		"<=" => Token{kind: TokenKind::Punct(Punct::LessEqual), ..},
		">=" => Token{kind: TokenKind::Punct(Punct::GreatEqual), ..},
		"==" => Token{kind: TokenKind::Punct(Punct::EqualEqual), ..},
		"!=" => Token{kind: TokenKind::Punct(Punct::BangEqual), ..},
		"^" => Token{kind: TokenKind::Punct(Punct::Carrot), ..},
		"|" => Token{kind: TokenKind::Punct(Punct::VBar), ..},
		"&&" => Token{kind: TokenKind::Punct(Punct::AmpAmp), ..},
		"||" => Token{kind: TokenKind::Punct(Punct::VBarVBar), ..},
		"?" => Token{kind: TokenKind::Punct(Punct::QMark), ..},
		":" => Token{kind: TokenKind::Punct(Punct::Colon), ..},
		"*=" => Token{kind: TokenKind::Punct(Punct::StarEqual), ..},
		"/=" => Token{kind: TokenKind::Punct(Punct::FSlashEqual), ..},
		"%=" => Token{kind: TokenKind::Punct(Punct::PercentEqual), ..},
		"+=" => Token{kind: TokenKind::Punct(Punct::PlusEqual), ..},
		"-=" => Token{kind: TokenKind::Punct(Punct::MinusEqual), ..},
		"<<=" => Token{kind: TokenKind::Punct(Punct::LessLessEqual), ..},
		">>=" => Token{kind: TokenKind::Punct(Punct::GreatGreatEqual), ..},
		"&=" => Token{kind: TokenKind::Punct(Punct::AmpEqual), ..},
		"^=" => Token{kind: TokenKind::Punct(Punct::CarrotEqual), ..},
		"|=" => Token{kind: TokenKind::Punct(Punct::VBarEqual), ..},
	}
}
