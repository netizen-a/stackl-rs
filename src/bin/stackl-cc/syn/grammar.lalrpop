use crate::syn::*;
use crate::tok::*;

use crate::diag::syn::Error as SyntaxError;

grammar;


// A.2.1 Expressions

PrimaryExpression: PrimaryExpression = {
	IDENT => todo!(),
	CONST => todo!(),
	STR_LIT => todo!(),
	"(" Expression ")" => todo!(),
};

PostfixExpression: PostfixExpression = {
	PrimaryExpression => todo!(),
	PostfixExpression "[" Expression "[" => todo!(),
	PostfixExpression "(" ArgumentExpressionList? ")" => todo!(),
	PostfixExpression "." IDENT => todo!(),
	PostfixExpression "->" IDENT => todo!(),
	PostfixExpression "++" => todo!(),
	PostfixExpression "--" => todo!(),
	"(" TypeName ")" "{" InitializerList "}" => todo!(),
	"(" TypeName ")" "{" InitializerList "," "}" => todo!(),
};

ArgumentExpressionList: ArgumentExpressionList = {
	AssignmentExpression => vec![<>],
	AssignmentExpressionList "," AssignmentExpression => todo!(),
};


// A.2.2 Declarations

Declaration: Declaration = {
	DeclarationSpecifiers InitDeclaratorList? ";" => todo!(),
};

DeclarationSpecifiers: Vec<DeclarationSpecifier> = DeclarationSpecifier+ => <>;

DeclarationSpecifier: DeclarationSpecifier = {
	StorageClassSpecifier => todo!(),
	// TypeSpecifier => todo!(),
	// TypeQualifier => todo!(),
	// FunctionSpecifier => todo!(),
};

InitDeclaratorList: Vec<InitDeclarator> = {
	InitDeclarator => vec![<>],
	InitDeclaratorList "," InitDeclarator => todo!(),
};

InitDeclarator: InitDeclarator = {
	Declarator => todo!(),
	Declarator "=" Initializer => todo!(),
};

StorageClassSpecifier: Keyword = {
	"typedef" => todo!(),
	"extern" => todo!(),
	"static" => todo!(),
	"auto" => todo!(),
	"register" => todo!(),
}

TypeSpecifier: TypeSpecifier = {
	"void" => todo!(),
	"char" => todo!(),
	"short" => todo!(),
	"int" => todo!(),
	"long" => todo!(),
	"float" => todo!(),
	"double" => todo!(),
	"signed" => todo!(),
	"unsigned" => todo!(),
	"_Bool" => todo!(),
	StructOrUnionSpecifier => todo!(),
	EnumSpecifier => todo!(),
	TypedefName => todo!(),
};

StructOrUnionSpecifier: StructOrUnionSpecifier = {
	StructOrUnion IDENT? "{" StructDeclarationList "}" => todo!(),
	StructOrUnion IDENT => todo!(),
};

StructOrUnion: Keyword = {
	"struct" => todo!(),
	"union" => todo!(),
};

StructDeclarationList: StructDeclarationList = StructDeclaration+ => todo!();

StructDeclaration: StructDeclaration = {
	SpecifierQualifierList StructDeclaratorList ";" => todo!(),
};

SpecifierQualifierList: Vec<SpecifierQualifier> = SpecifierQualifier+ => <>;

SpecifierQualifier: SpecifierQualifier = {
	TypeSpecifier => todo!(),
	TypeQualifier => todo!(),
};

StructDeclaratorList: Vec<StructDeclarator> = {
	StructDeclarator => vec![<>],
	StructDeclaratorList "," StructDeclarator => todo!(),
};

StructDeclarator: StructDeclarator = {
	Declarator => todo!(),
	Declarator? ":" ConstantExpression => todo!(),
};

EnumSpecifier: EnumSpecifier = {
	"enum" IDENT? "{" EnumeratorList "}" => todo!(),
	"enum" IDENT? "{" EnumeratorList "," "}" => todo!(),
	"enum" IDENT => todo!(),
};

EnumeratorList: Vec<Enumerator> = {
	Enumerator => vec![<>],
	EnumeratorList "," Enumerator => todo!(),
};

Enumerator: Enumerator = {
	EnumerationConstant => todo!(),
	EnumerationConstant "=" ConstantExpression => todo!(),
};

TypeQualifier: Keyword = {
	"const" => todo!(),
	"restrict" => todo!(),
	"volatile" => todo!(),
};

FunctionSpecifier: Keyword = "inline" => <>;

Declarator: Declarator = {
	Pointer? DirectDeclarator => todo!(),
};

DirectDeclarator: DirectDeclarator = {
	IDENT => todo!(),
	"(" Declarator ")" => todo!(),
	DirectDeclarator "[" TypeQualifierList? AssignmentExpression? "]" => todo!(),
	DirectDeclarator "[" STATIC TypeQualifierList? AssignmentExpression "]" => todo!(),
	DirectDeclarator "[" TypeQualifierList STATIC AssignmentExpression "]" => todo!(),
	DirectDeclarator "[" TypeQualifierList? "*" "]" => todo!(),
	DirectDeclarator "(" ParameterTypeList ")" => todo!(),
	DirectDeclarator "(" IdentifierList? ")" => todo!(),
};

Pointer: Pointer = {
	"*" TypeQualifierList? => todo!(),
	"*" TypeQualifierList? Pointer => todo!(),
};

TypeQualifierList: TypeQualifierList = {
	TypeQualifier+ => todo!(),
};

ParameterTypeList: ParameterTypeList = {
	ParameterList => todo!(),
	ParameterList "," "..." => todo!(),
};

ParameterList: Vec<ParameterDeclaration> = {
	ParameterDeclaration => vec![<>],
	ParameterList "," ParameterDeclaration => todo!(),
};

ParameterDeclaration: ParameterDeclaration = {
	DeclarationSpecifiers Declarator => todo!(),
	DeclarationSpecifiers AbstractDeclarator? => todo!(),
};

IdentifierList: Vec<Ident> = {
	IDENT => vec![<>],
	IdentifierList "," IDENT => todo!(),
};

TypeName: TypeName = {
	SpecifierQualifierList AbstractDeclarator? => todo!(),
};

AbstractDeclarator: AbstractDeclarator = {
	Pointer => todo!(),
	Pointer? DirectAbstractDeclarator => todo!(),
};

DirectAbstractDeclarator: DirectAbstractDeclarator = {
	"(" AbstractDeclarator ")" => todo!(),
	DirectAbstractDeclarator? "[" AssignmentExpression? "]" => todo!(),
	DirectAbstractDeclarator? "[" "*" "]" => todo!(),
	DirectAbstractDeclarator? "(" ParameterTypeList? ")" => todo!(),
};

TypedefName: Ident = IDENT => <>;

Initializer: Initializer = {
	// AssignmentExpression => todo!(),
	"{" InitializerList "}" => todo!(),
	"{" InitializerList "," "}" => todo!(),
};

InitializerList: InitializerList = {
	Designation? Initializer => todo!(),
	InitializerList "," Designation? Initializer => todo!(),
};

Designation: Designation = {
	DesignatorList "=" => todo!(),
};

DesignatorList: DesignatorList = {
	Designator+ => todo!(),
};

Designator: Designator = {
	// "[" ConstantExpression "]" => todo!(),
	"." IDENT => todo!(),
};


// A.2.3 Statements

Statement: Statement = {
	LabeledStatement => todo!(),
	CompoundStatement => todo!(),
	ExpressionStatement => todo!(),
	SelectionStatement => todo!(),
	IterationStatement => todo!(),
	JumpStatement => todo!(),
};

LabeledStatement: LabeledStatement = {
	IDENT ":" Statement => todo!(),
	"case" ConstantExpression ":" Statement => todo!(),
	"default" ":" Statement => todo!(),
};

CompoundStatement: CompoundStatement = {
	"{" BlockItemList? "}" => todo!(),
};

BlockItemList: BlockItemList = {
	BlockItem+ => todo!(),
};

BlockItem: BlockItem = {
	Declaration => todo!(),
	Statement => todo!(),
};

ExpressionStatement: ExpressionStatement = {
	Expression? ";" => todo!(),
};

SelectionStatement: SelectionStatement = {
	"if" "(" Expression ")" Statement => todo!(),
	"if" "(" Expression ")" Statement => "else" Statement => todo!(),
	"switch" "(" Expression ")" Statement => todo!(),
};

IterationStatement: IterationStatment = {
	"while" "(" Expression ")" Statement => todo!(),
	"do" Statement "while" "(" Expression ")" ";"
	"for" "(" Expression? ";" Expression? ";" Expression? ")" Statement => todo!(),
	"for" "(" Declaration Expression? ";" Expression? ")" Statement => todo!(),
};

JumpStatement: JumpStatment = {
	"goto" IDENT ";" => todo!(),
	"continue" ";" => todo!(),
	"break" ";" => todo!(),
	"return" Expression? => todo!(),
};


// A.2.4 External definitions

pub TranslationUnit: TranslationUnit = ExternalDeclaration+ => {
	TranslationUnit {
		external_declaration: <>,
	}
};

ExternalDeclaration: ExternalDeclaration = {
	FunctionDefinition => ExternalDeclaration::FunctionDefinition(<>),
	Declaration => ExternalDeclaration::Declaration(<>),
};

FunctionDefinition: FunctionDefinition = {
	DeclarationSpecifiers Declarator DeclarationList? CompoundStatement => todo!(),
};

DeclarationList: Vec<Declaration> = Declaration+ => <>;


extern {
	type Location = usize;
	type Error = SyntaxError;

	enum Token {
		IDENT => Token{kind: TokenKind::Ident(_), ..},
		"typedef" => Token{kind: TokenKind::Keyword(Keyword::Typedef), ..},
		"extern" => Token{kind: TokenKind::Keyword(Keyword::Extern), ..},
		"static" => Token{kind: TokenKind::Keyword(Keyword::Static), ..},
		"auto" => Token{kind: TokenKind::Keyword(Keyword::Auto), ..},
		"register" => Token{kind: TokenKind::Keyword(Keyword::Register), ..},
		"void" => Token{kind: TokenKind::Keyword(Keyword::Void), ..},
		"char" => Token{kind: TokenKind::Keyword(Keyword::Char), ..},
		"short" => Token{kind: TokenKind::Keyword(Keyword::Short), ..},
		"int" => Token{kind: TokenKind::Keyword(Keyword::Int), ..},
		"long" => Token{kind: TokenKind::Keyword(Keyword::Long), ..},
		"float" => Token{kind: TokenKind::Keyword(Keyword::Float), ..},
		"double" => Token{kind: TokenKind::Keyword(Keyword::Double), ..},
		"signed" => Token{kind: TokenKind::Keyword(Keyword::Signed), ..},
		"unsigned" => Token{kind: TokenKind::Keyword(Keyword::Unsigned), ..},
		"_Bool" => Token{kind: TokenKind::Keyword(Keyword::Bool), ..},
		"const" => Token{kind: TokenKind::Keyword(Keyword::Const), ..},
		"restrict" => Token{kind: TokenKind::Keyword(Keyword::Restrict), ..},
		"volatile" => Token{kind: TokenKind::Keyword(Keyword::Volatile), ..},
		"enum" => Token{kind: TokenKind::Keyword(Keyword::Enum), ..},
		"struct" => Token{kind: TokenKind::Keyword(Keyword::Struct), ..},

		"." => Token{kind: TokenKind::Punct(Punct::Dot), ..},
		"," => Token{kind: TokenKind::Punct(Punct::Comma), ..},
		"=" => Token{kind: TokenKind::Punct(Punct::Equal), ..},
		"*" => Token{kind: TokenKind::Punct(Punct::Star), ..},
		"{" => Token{kind: TokenKind::Punct(Punct::LCurly), ..},
		"}" => Token{kind: TokenKind::Punct(Punct::RCurly), ..},
		";" => Token{kind: TokenKind::Punct(Punct::SemiColon), ..},
		"(" => Token{kind: TokenKind::Punct(Punct::LParen), ..},
		")" => Token{kind: TokenKind::Punct(Punct::RParen), ..},
	}
}
