\documentclass[11pt,a4paper,oneside]{book}

% ---- Page Layout ----
\usepackage[margin=1in]{geometry}

\usepackage{booktabs}

% Better PDF links
\usepackage[hidelinks]{hyperref}

% ---- Fonts ----
\usepackage{palatino}

% Fix tables drifting to bottom
\usepackage{float}
\restylefloat{table}


\makeatletter
\renewcommand{\maketitle}{%
  \vspace*{2cm} % Add some space from the top
  \begin{center}
    \begingroup
      \hrule height 2pt % Optional: Thick line above the title
      \vspace{0.5\baselineskip}
      {\Huge \bfseries \@title \par}% Title is large and bold
      \vspace{0.5\baselineskip}
      \hrule height 1pt % Optional: Thin line below the title
    \endgroup
    \par
  \end{center}
  \vfill % Push everything below this point to the bottom of the page
  % --- Author and Date at Bottom ---
  \begin{center}
    \begingroup
      \footnotesize
      \hrule height 0.5pt % Thin separator line
      \vspace{0.5em}
      \@author \quad $\cdot$ \quad \@date % Print Author and Date separated by a dot
      \vspace{0.5em}
    \endgroup
  \end{center}
}
\makeatother



\title{
	STACKL Architecture\\
	Programmer's Manual\\
	\large Volume 1: Basic Architecture
}

\author{Jonathan Thomason}

\begin{document}

\frontmatter
\thispagestyle{empty}
\maketitle

\setcounter{page}{0}
\tableofcontents

\chapter{Preface}

\section{About This Book}
This book is part of a multivolume work entitled the \textit{STACKL Architecture
Programmer's Manual}. This table lists each volume in the series.

\begin{table}[H]
\centering
	\begin{tabular}{l}
		STACKL Architecture Programmer's Manual Volume 1: Basic Architecture\\
		STACKL Architecture Programmer's Manual Volume 2: Instruction Set Reference\\
		STACKL Architecture Programmer's Manual Volume 3: System Programming Guide\\
	\end{tabular}
\end{table}

\section{Audience}
This volume is intended for system architects, hardware implementers,
interpreter developers, and others requiring a precise understanding of
the STACKL architectural model.

\section{Scope of This Volume}
This volume describes the architectural state visible to software running on
STACKL, including the organization of its stacks, registers, program counter,
and condition flags.

It defines the execution model, memory address space, and interrupt vector
mechanism, establishing the foundation for software development on the
STACKL virtual machine.

Details of instruction encoding and semantics are covered in *Volume 2:
Instruction Set Reference*, while system-level programming conventions and
runtime environment are described in *Volume 3: System Programming Guide*.

\mainmatter
% your content goes here

\chapter{Registers}

\section{Execution Registers}
\subsection{Instruction Pointer (IP)}
The instruction pointer (IP) contains the address of the next instruction to be executed.

\subsection{Stack Pointer (SP)}
The stack pointer (SP) contains the address of the first unused memory location at the top of the stack. The stack grows to increasing memory addresses.

\subsection{Frame Pointer (FP)}
The frame pointer (FP) is used for function calls. It points to the location of the first local variable in a called function.

\section{Flag Register (FLAG)}
The flag register (FLAG) contains bits that identify the mode the processor is in. The following bits are defined:
\begin{itemize}
  \item 0: HALTED - The CPU will stop and the interpreter will exit when this bit is set
  \item 1: USER\_MODE - The CPU is in user mode when this bit is set
  \item 2: INT\_MODE - The CPU is executing in interrupt mode when this bit is set
  \item 3: INT\_DIS - Interrupts are disabled when this bit is set
  \item 4: VMEM - The CPU is operating in virtual memory mode when this bit is set (not yet implemented)
  \item 16: I\_MACH - A machine check is pending
  \item 17: I\_TRAP - A trap instruction is pending
\end{itemize}

\section{Interrupt Vector (IVEC)}
The interrupt vector (IVEC) contains the absolute address of the interrupt vector table. The interrupt vector table should be large enough to contain 16 word-sized interrupt vectors.

\section{Memory Management Registers}
\subsection{Base Pointer (BP)}
The base pointer (BP) contains the address of the start of memory for the current process. All memory addresses are relative to the Base Pointer (BP).

\subsection{Limit Pointer (LP)}
The limit pointer (LP) contains the value just above the highest memory that a process can access. Legal memory access must be within the range of BP to LP-1.

\section{Stack Frames}
The stack frame structure is as follows:
\begin{itemize}
  \item The caller pushes parameters onto the stack from right to left
  \item The CALL instruction pushes the return address and frame pointer onto the stack
  \item Interrupt stack frames must not contain local variables (the SP is adjusted to make room)
  \item The RTI instruction restores state based on the SP, not the FP
\end{itemize}

\chapter{Program Counter}
\section{Instruction Pointer (IP)}
The instruction pointer (IP) contains the address of the next instruction to be executed.

\chapter{Condition Flags}
The condition flags are status indicators stored in the FLAG register that reflect the outcome of arithmetic and comparison operations. These flags are used by conditional branch instructions to determine execution flow. For example, the EQ instruction (Section 7.12) sets the zero flag (bit 0) when two values are equal, enabling conditional jumps via instructions like JUMPE (Section 7.20).

\chapter{Execution Model}
The STACKL machine operates on a stack-based architecture with no general-purpose registers. All operations manipulate the stack: operands are popped from the stack, the operation is performed, and the result is pushed back onto the stack. The instruction pointer (IP) tracks the next instruction to execute. The machine supports two execution modes:
\begin{itemize}
  \item User mode (bit 1 set in FLAG register)
  \item Interrupt mode (bit 2 set in FLAG register)
\end{itemize}
Mode transitions occur via instructions like CALL (for function calls) and RTI (for interrupt returns). The stack pointer (SP) grows to higher memory addresses, with the stack frame structure managed by the frame pointer (FP). This model enables efficient handling of procedure calls and interrupts within the virtual machine environment.

\chapter{Memory Model}
The STACKL memory model employs a base-relative addressing scheme where all memory addresses are relative to the Base Pointer (BP). The Base Pointer (BP) defines the start of a process's memory region, and the Limit Pointer (LP) specifies the upper bound (BP to LP-1). Memory accesses are computed as physical address = BP + logical address, with the system enforcing that all accesses remain within the valid bounds.

Key aspects of the memory model:
\begin{itemize}
  \item **Base-relative addressing**: Logical addresses are offset from BP, enabling isolated process address spaces.
  \item **Bounds enforcement**: Accesses outside BP d address < LP trigger a machine check (bit 16 set in FLAG register).
  \item **Process isolation**: Each process has unique BP/LP values, preventing memory interference between processes.
  \item **Context switching**: During process transitions, BP and LP are updated to point to the new process's memory region.
  \item **Integration with stack frames**: Stack frame operations (e.g., CALL, POP) operate within BP/LP bounds, ensuring memory safety.
\end{itemize}
This model is fundamental to the architecture's security and stability, preventing buffer overflows and unauthorized memory access.

\chapter{Procedure Calls}
The STACKL architecture uses a stack-based calling convention for procedure calls. Parameters are pushed onto the stack from right to left (e.g., for function call foo(a,b,c), push c, then b, then a), and the CALL instruction handles the rest.

\section{CALL Instruction}
The CALL instruction (Section 7.6) performs the following operations:
\begin{itemize}
  \item Pushes the return address (IP+1) onto the stack
  \item Pushes the current frame pointer (FP) onto the stack
  \item Sets FP = SP (new frame pointer)
  \item Updates IP to the target address
\end{itemize}
This creates a new stack frame frame as follows:
\begin{itemize}
  \item The top two words on the stack contain the return address and the old frame pointer
  \item The current stack pointer (SP) points to the top of this new frame
  \item The frame pointer (FP) points to the first local variable in the called function
\end{itemize}

\section{Stack Frame Management}
The stack frame is managed as follows:
\begin{itemize}
  \item The caller pushes parameters onto the stack from right to left
  \item The CALL instruction pushes the return address and frame pointer
  \item The called function sets FP = SP (establishing the frame)
  \item Local variables are allocated by adjusting SP (using ADJSP)
  \item The return address is popped from the stack when the function returns
  \item The frame pointer (FP) is restored from the stack
  \item The stack pointer (SP) is adjusted to remove the parameters
\end{itemize}

\chapter{Interrupts}
The STACKL architecture supports up to 16 interrupt vectors (0-15), with specific assignments:
\begin{itemize}
  \item Vector 0: Machine check (interrupt 0)
  \item Vector 1: TRAP instruction (system calls)
  \item Vectors 2-15: Available for hardware devices (e.g., timer, disk)
\end{itemize}

\section{Interrupt Vector Table (IVT)}
The IVT stores addresses of interrupt service routines (ISRs) for each vector. The IVEC register points to the IVT. Vectors 0-1 are reserved; unused vectors (2-15) should be initialized to 0x0001 to trigger machine checks on access.

\section{Interrupt Handling Process}
1. Hardware signals interrupt (sets bit 16-31 in FLAG)
2. Processor checks if interrupts enabled (bit 3 clear) and not in interrupt mode (bit 2 clear)
3. Highest priority interrupt (lowest bit number) is serviced
4. Processor jumps to ISR address from IVT

\section{Example ISR Setup}
\begin{verbatim}
#pragma interrupt machine_check_isr
int machine_check_isr() { /* handle */ asm("RTI"); }

#pragma interrupt trap_isr
int trap_isr() { /* handle */ asm("RTI"); }

int Interrupt_Vector[16];

void startup() {
  Interrupt_Vector[0] = machine_check_isr;
  Interrupt_Vector[1] = trap_isr;
  asm("POPREG", IVEC_REG, &Interrupt_Vector);
}
\end{verbatim}

Note: Unused vectors (2-15) must be initialized to 0x0001 for safety.

\chapter{Machine Checks}
Machine checks occur when the processor detects an invalid operation, such as:
\begin{itemize}
  \item Memory access outside the process's address space (BP d address < LP)
  \item Illegal instruction (e.g., ILLEGAL opcode)
  \item Stack overflow/underflow
\end{itemize}
The machine check is indicated by setting bit 16 (I\_MACH) in the FLAG register. When this bit is set, the processor halts execution and triggers the machine check interrupt (vector 0).

The machine check interrupt (vector 0) is handled by a dedicated interrupt service routine (ISR) that typically terminates the program. The ISR must be defined with:
\begin{verbatim}
#pragma interrupt machine_check_isr
int machine_check_isr() {
    /* handle machine check */
    asm("RTI");
}
\end{verbatim}
This ISR is registered in the interrupt vector table (section 4.9), where vector 0 points to the machine\_check\_isr function.

The machine check mechanism is critical for system stability, as it prevents invalid memory accesses and illegal operations from corrupting the virtual machine state. It is triggered automatically by the processor hardware when a violation occurs.

\chapter{Control Transfers}
The STACKL architecture provides several instructions for controlling program flow, including unconditional jumps, conditional jumps, and returns from procedures.

\section{Unconditional Jumps}
The JUMP instruction (Section 7.19) performs an unconditional jump to the specified address. This instruction has the following effect:
\begin{verbatim}
IP = <dest>
\end{verbatim}

\section{Conditional Jumps}
Conditional jump instructions check the top of the stack for a zero value before deciding to jump. The JUMPE instruction (Section 7.20) has the following effect:
\begin{verbatim}
SP--
val = Memory[SP]
if (val == 0)
   IP = <dest>
else
   IP += 2
\end{verbatim}

\section{Returns}
The RETURN instruction (Section 7.46) is used to return from a void function. It has the following effect:
\begin{verbatim}
SP = FP-1
IP = Memory[FP-2]
FP = Memory[FP-1]
\end{verbatim}

The RTI instruction (Section 7.48) is used to return from interrupt mode. It has the following effect:
\begin{verbatim}
FL_USER_MODE bit is set in FLAG register
IP = Memory[SP-1]
SP = Memory[SP-2]
\end{verbatim}

These instructions form the core control transfer mechanisms of the STACKL architecture, enabling complex program flow control.

\chapter{Input/Output}
The STACKL architecture provides two primary instructions for input/output operations: the OUTS instruction for output and the INP instruction for input.

\section{Output Operations}
The OUTS instruction (Section 7.30) outputs a null-terminated string to the console. It has the following effect:
\begin{verbatim}
val = Memory[SP]
SP--
IP++
\end{verbatim}
The value at the top of the stack must be the address of a null-terminated string. This is a blocking operation: the processor will not execute the next instruction until the output operation completes.

\section{Input Operations}
The INP instruction (Section 7.17) initiates an input operation using an IO block structure. The IO block has the following format:
\begin{verbatim}
typedef struct {
   int op;
   void *param1;
   int param2;
} io_blk_t;
\end{verbatim}
The 'op' field specifies the operation:
\begin{itemize}
  \item INP\_PRINTS\_CALL (3): Prints a string from param1
  \item INP\_GETS\_CALL (5): Reads a string from console
  \item INP\_GETI\_CALL (7): Reads an integer from console
\end{itemize}
The INP instruction is non-blocking: the processor continues execution while waiting for the operation to complete. The caller must poll the 'op' field until it becomes negative (indicating completion).

\section{Device Integration}
The architecture supports multiple I/O devices through memory-mapped registers:
\begin{itemize}
  \item \textbf{PIO Terminal}: Device 0x0E000000, used for console I/O (vector 5)
  \item \item \textbf{Timer}: Device 0x0C000000, used for timing (vector 3)
  \item \textbf{Disk}: Device 0x0D000000, used for disk access (vector 2)
\end{itemize}
To enable a device, use the appropriate pragma:
\begin{verbatim}
#pragma feature pio_term
\end{verbatim}
The device registers are accessed using standard memory access instructions, with the device's address space offset from the base address.

The OUTS instruction is used for simple console output, while the INP instruction provides more flexible input operations. Both instructions are fundamental to the interaction between the STACKL virtual machine and the underlying hardware devices.

\chapter{Overview of the CPU Instruction Set}
The STACKL architecture features a comprehensive instruction set designed for stack-based operations. The instruction set is categorized into key functional groups:

\section{Arithmetic Operations}
Instructions such as PLUS, MINUS, TIMES, and DIVIDE perform basic arithmetic operations on stack operands. These instructions pop two values from the stack, compute the result, and push it back onto the stack.

\section{Stack Management}
Stack operations include:
\begin{itemize}
  \item PUSH: Pushes a value onto the stack
  \item POP: Removes a value from the stack
  \item DUP: Duplicates the top stack value
  \item SWAP: Exchanges the top two stack values
\end{itemize}

\section{Control Flow}
Control flow instructions manage program execution:
\begin{itemize}
  \item JUMP: Unconditional jump to a specified address
  \item JUMPE: Conditional jump if top stack value is zero
  \item CALL: Function call with return address
  \item RETURN: Return from function
\end{itemize}

\section{Memory Access}
Memory operations include:
\begin{itemize}
  \item PUSHVAR: Pushes a variable from the frame pointer
  \item POPVAR: Pops a value into a variable
  \item ADJSP: Adjusts the stack pointer
\end{itemize}

\section{Special Operations}
System-level instructions:
\begin{itemize}
  \item TRAP: Triggers a system call
  \item INP: Initiates input operations
  \item OUTS: Outputs a null-terminated string
\end{itemize}

This overview provides the fundamental structure. Detailed instruction semantics and encoding are covered in Volume 2: Instruction Set Reference.

\chapter{Overview of the FPU Instruction Set}

\chapter{Instruction Bit Encodings}

\end{document}
