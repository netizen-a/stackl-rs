\documentclass[11pt,a4paper,oneside]{book}

% ---- Page Layout ----
\usepackage[margin=1in]{geometry}
\usepackage{booktabs}
% Better PDF links
\usepackage[hidelinks]{hyperref}
% Fix tables drifting to bottom
\usepackage{float}
\restylefloat{table}

% Fonts
\usepackage{palatino}

\usepackage{enumitem}

% Author/title macros
\makeatletter
\renewcommand{\maketitle}{%
  \vspace*{2cm} % Add some space from the top
  \begin{center}
    \begingroup
      \hrule height 2pt % Optional: Thick line above the title
      \vspace{0.5\baselineskip}
      {\Huge \bfseries \@title \par}% Title is large and bold
      \vspace{0.5\baselineskip}
      \hrule height 1pt % Optional: Thin line below the title
    \endgroup
    \par
  \end{center}
  \vfill % Push everything below this point to the bottom of the page
  % --- Author and Date at Bottom ---
  \begin{center}
    \begingroup
      \footnotesize
      \hrule height 0.5pt % Thin separator line
      \vspace{0.5em}
      \@author $\cdot$ \quad $\backslash$today{} % Print Author and Date separated by a dot
      \vspace{0.5em}
    \endgroup
  \end{center}
}
\makeatother

\title{
	STACKL Architecture\\
	Programmer's Manual\\
	\large Volume 1: Basic Architecture
}

\author{Jonathan Thomason}

\begin{document}

\frontmatter
\thispagestyle{empty}
\maketitle

\setcounter{page}{0}
\tableofcontents

\chapter{Preface}

\section{About This Book}
This book is part of a multivolume work entitled the \textit{STACKL Architecture
Programmer's Manual}.  The series comprises:

\begin{table}[H]
\centering
	\begin{tabular}{l}
		STACKL Architecture Programmer's Manual Volume 1: Basic Architecture\\
		STACKL Architecture Programmer's Manual Volume 2: Instruction Set Reference\\
		STACKL Architecture Programmer's Manual Volume 3: System Programming Guide\\
	\end{tabular}
\end{table}

\section{Audience}
System architects, hardware implementers, interpreter developers, and others
who need a precise understanding of the STACKL architectural model.

\section{Scope of This Volume}
The volume describes the architectural state visible to software running on
STACKL.  It covers the organization of stacks, registers, program counter,
condition flags, interrupt vector mechanism, memory address space rules, and
the execution model that underpins all higher-level abstractions.
Details of instruction encoding and semantics are reserved for *Volume-2:
Instruction Set Reference*; system-level programming conventions are covered
in *Volume-3: System Programming Guide*.

\mainmatter

\chapter{Registers}

\section{Execution Registers}
\subsection{Instruction Pointer (IP)}
The IP holds the address of the next instruction to fetch.  It is updated by all
control-transfer instructions.

\subsection{Stack Pointer (SP)}
SP points to the first unused location on a word-aligned stack that grows toward
higher addresses.

\subsection{Frame Pointer (FP)}
FP points to the first local variable of a currently executing function.
It is used by CALL/RETURN and by access patterns such as `PUSHVAR`, `POPVAR`,
`POPCVAR`, etc.

\section{Flag Register (FLAG)}
Each bit encodes a status condition:

\begin{tabular}{@{}ll@{}}
\toprule
Bit & Meaning \\ \midrule
0     & HALTED - execution stops when set           \\
1     & USER\_MODE - 1 = user mode, 0 = system mode \\
2     & INT\_MODE - interrupt mode in progress    \\
3     & INT\_DIS - interrupts disabled when set   \\
4     & VMEM - virtual memory mode (not implemented) \\
16    & I\_MACH - machine-check pending           \\
17    & I\_TRAP - trap instruction pending        \\ \bottomrule
\end{tabular}

The flag register is manipulated implicitly by many instructions and can be
read or cleared with `CLID`/`SEID`.

\section{Interrupt Vector (IVEC)}
IVEC stores the base address of a 16-entry interrupt vector table.  Upon an
interrupt, the processor indices this table to fetch the service routine's
address.

\chapter{Stack Frames}

The stack frame for a normal function call consists of:

\begin{itemize}
   \item Return address (IP+1) pushed by CALL.
   \item Current FP pushed by CALL.
   \item Local variables allocated below FP using `ADJSP`.
\end{itemize}

Interrupt stack frames omit the FP update; they must be returned with
`RTI`, which restores SP and FL directly.

\chapter{Interrupts}

\section{Vector Assignment}
\begin{itemize}
   \item 0 - Machine check
   \item 1 - TRAP (system calls)
   \item 2-15 - Available for hardware devices (timer, disk, pio\_term,
            etc.)
\end{itemize}

\section{Service Routine Registration}
A typical startup routine populates the vector table:

\begin{verbatim}
#pragma interrupt machine_check_isr
int machine_check_isr() { asm("RTI"); }

#pragma interrupt trap_isr
int trap_isr() { /* ... */ asm("RTI"); }

int Interrupt_Vector[16];

void startup(void) {
    Interrupt_Vector[0] = machine_check_isr;
    Interrupt_Vector[1] = trap_isr;
    asm2("POPREG", IVEC_REG, &Interrupt_Vector);
}
\end{verbatim}

Unused entries (vectors 2-15) should be initialized to $0x0001$ to force a
machine check if accessed accidentally.

\section{Execution Flow}
An interrupt is taken only when the FLAG bits satisfy:
\begin{itemize}
   \item INT\_EN set,
   \item USER\_MODE or not already in INT\_MODE,
   \item No higher-priority pending interrupt.
\end{itemize}
The highest-numbered bit (lowest priority) that satisfies these conditions
triggers the corresponding ISR.

\chapter{Interrupt Vector Table Layout}

\(\textbf{Note:} \)  A separate \textit{Volume-2} contains the full instruction set reference and a more exhaustive enumeration of opcodes.

\chapter{Memory Model}

All logical addresses are interpreted as offsets from the Base Pointer (BP).
Legal accesses satisfy \(BP+d < LP\).
The loader sets BP, LP, and an initial stack size after loading a binary; see Section~\ref{sec:loader} for details.

\chapter{Procedure Calls}

A CALL pushes:

\begin{enumerate}
   \item Return address (IP+1)
   \item Previous FP
\end{enumerate}
then jumps to the target.  The callee retrieves these values via
`POPREG`/`RETURN`.  Arguments are passed by pushing onto the stack before the
CALL; they are removed with `POPARGS <size>` on return.

\chapter{System Trap}

The TRAP instruction invokes a system-call routine supplied in the trap vector.
It passes any parameters left on the stack to that routine, which must exit via
`RTI`.  System traps enable privileged operations such as I/O configuration,
memory allocation, or process creation.

\chapter{Devices Overview}

\section{Programmed IO Terminal (pio\_term)}
Enabled with \(\texttt{feature pio\_term}\).  Register map:

\begin{tabular}{@{}ll@{}}
RDR   & $0x0E000000$ - read-only, receives characters      \\
XDR   & $0x0E000000$ - write-only, sends characters    \\
IER   & $0x0E000001$ - interrupt enable (RECV/XMIT)     \\
IIR   & $0x0E000002$ - read-only interrupt status       \\ \hline
\end{tabular}

Bits:
\begin{itemize}
   \item IID\_INT  = $0x01$
   \item IID\_RECV = $0x02$
   \item IID\_XMIT = $0x04$
\end{itemize}

\section{Timer}
Base address \(0x0C000000\); registers:

\begin{tabular}{@{}ll@{}}
TIMER\_CSR & Bit-0 = interrupt enable, Bit-31 = pending interrupt   \\
TIMER\_COUNT & increments each instruction                \\
TIMER\_LIMIT & generates interrupt when COUNT >= LIMIT            \\
TIMER\_TIME  & monotonic instruction counter                        \\ \hline
Timer uses vector-3.
\end{tabular}

\section{Disk}
Base address \(0x0D000000\); registers:

\begin{verbatim}
DISK_STATUS    // read-only, bits: READ_BUSY, READ_DONE,
               //      READ_ERROR, WRITE_BUSY,...ATTN
DISK_CMD       // write only; INT_ENA, START_READ,
              //     START_WRITE
DISK_ADDR        // absolute address of buffer
DISK_BLOCK       // block number to transfer                \\
\end{verbatim}
All accesses are word-aligned.  Disk uses vector-2.

\section{Generic IO Device}
Base \texttt{0x0B00000} with command byte in the low byte; supported operations:

\begin{tabular}{@{}ll@{}}
GEN\_IO\_OP\_PRINTS   = 1 ; \texttt{prints(str)}\\
GEN\_IO\_OP\_PRINTC   = 2 ; \texttt{putc(c)}\\
GEN\_IO\_OP\_GETL     = 3 ; \texttt{gets(buf)}\\
GEN\_IO\_OP\_GETI     = 4 ; \texttt{geti(val)}\\
GEN\_IO\_OP\_EXEC     = 5 ; \texttt{loader via INP\_EXEC\_CALL}\\
\end{tabular}

\chapter{Loader and Execution Flow}

\label{sec:loader}
Program binaries have the form:

\begin{enumerate}
   \item Series of newline-terminated text records:
     \begin{itemize}
        \item version line (\(\texttt{stackl}<v>\texttt{slam}\)),
        \item optional feature lines (e.g., \(\texttt{feature pio\_term}\)),
        \item \(\texttt{stack\_size <n>}\)
        \item \(\texttt{begindata}\)
     \end{itemize}
   \item Binary data (32-bit words) following \(\texttt{begindata}\).\\
\end{enumerate}

The loader:

\begin{enumerate}
   \item Reads records until it encounters \(\texttt{begindata}\).
   \item For each record, validates or initializes the corresponding
        feature, stacksize, etc.
   \item Begins loading 32-bit words into memory starting at address BP.
   \item After loading completes, stores high water mark in the word immediately
        after the loaded region; this value is used to set LP and later as stack size.
\end{enumerate}

After loading, user code is entered with:

\begin{verbatim}
asm2("POPREG", BP_REG, start_addr);
io_blk.op = INP_EXEC_CALL;
io_blk.param1 = filename;
io_blk.param2 = 0;
asm("INP", &io_blk);               // non-blocking
// wait loop omitted for brevity ...
asm2("POPREG", LP_REG, high_mem);
asm("DUP", io_blk.param2 + 4 - start_addr);
asm2("POPREG", FP_REG);
asm("POPREG", SP_REG);
asm2("JMPUSER", 8);                  // user entry at address-8 (relative)
\end{verbatim}

The newly established stack frame must be used thereafter; all subsequent
memory accesses are interpreted relative to the updated BP/LP pair.

\chapter{Instruction Reference Overview}
% The full detailed opcode list resides in Volume-2.
A high-level overview of functional groups is provided here:

\begin{itemize}
   \item \textbf{Arithmetic}: PLUS, MINUS, TIMES, DIVIDE, MOD .
   \item \textbf{Logic \& Comparison}: AND, OR, NOT, EQ, GE, LT .
   \item \textbf{Stack Manipulation}: PUSH, POP, DUP, SWAP .
   \item \textbf{Control Flow}: JUMP, JUMPE, CALL, RETURN .
   \item \textbf{I/O}\\
        -- OUTS (output null-terminated string) \\
        -- INP  (non-blocking input via io\_blk\_t)
   \item \textbf{Register Access:} PUSHREG, POPREG, ADJSP .
\end{itemize}

Detailed semantics, encoding tables, and examples appear in the companion
volume.

\chapter{Glossary}
\begin{description}[style=multiline,leftmargin=4.5cm]
\item[BP] Base Pointer - start of a process's address space.
\item[LP] Limit Pointer - upper bound of legal memory accesses.
\item[IP] Instruction Pointer.
\item[SP] Stack Pointer.
\item[FP] Frame Pointer.
\item[FLAG] Condition-status register.
\item[IVEC] Interrupt Vector Register - base of vector table.
\item[TRAP] System-call entry point.
\item[INTERUPT\_VECTOR] 16-entry table of ISR addresses.
\end{description}

\appendix
\chapter{Machine Check Mechanism}
A machine check occurs when the processor detects an illegal operation (e.g.,
out-of-bounds memory access).  The hardware sets bit-16 (I\_MACH) in FLAG;
the resulting interrupt is serviced by ISR~0 (vector-0).

\chapter{Example Minimal Program}
\begin{verbatim}
#pragma startup __startup
int __startup(void) {
    main();
    asm("HALT");
}
#endif
\end{verbatim}

The preceding sections constitute a complete, self-contained reference for the
basic STACKL execution model and architecture.  All low-level opcodes,
encoding tables, and exhaustive examples are collected in Volume-2.

\backmatter

% \begin{thebibliography}{9}
% % bibliography entries would be placed here.
% \end{thebibliography}

\end{document}
